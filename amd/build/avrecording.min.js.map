{"version":3,"file":"avrecording.min.js","sources":["../src/avrecording.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n//\n\n/**\n * JavaScript to the recording work.\n *\n * We would like to thank the creators of atto_recordrtc, whose\n * work originally inspired this.\n *\n * This script uses some third-party JavaScript and loading that within Moodle/ES6\n * requires some contortions. The main classes here are:\n *\n * * Recorder - represents one recording widget. This works in a way that is\n *   not particularly specific to this question type.\n * * RecordRtcQuestion - represents one question, which may contain several recorders.\n *   It deals with the interaction between the recorders and the question.\n *\n * @module    qtype_recordrtc/avrecording\n * @copyright 2019 The Open University\n * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Log from 'core/log';\nimport ModalFactory from 'core/modal_factory';\nimport Templates from 'core/templates';\n\n/**\n * Verify that the question type can work. If not, show a warning.\n *\n * @return {string} 'ok' if it looks OK, else 'nowebrtc' or 'nothttps' if there is a problem.\n */\nfunction checkCanWork() {\n    // Check APIs are known.\n    if (!(navigator.mediaDevices && window.MediaRecorder)) {\n        return 'nowebrtc';\n    }\n\n    // Check protocol (localhost).\n    if (location.protocol === 'https:' ||\n            location.host === 'localhost' || location.host === '127.0.0.1') {\n        return 'ok';\n    } else {\n        return 'nothttps';\n    }\n}\n\n/**\n * Object for actually doing the recording.\n *\n * The recorder can be in one of several states, which is stored in a data-state\n * attribute on the outer span (widget). The states are:\n *\n *  - new:       there is no recording yet. Button shows 'Start recording' (audio) or 'Start camera' (video).\n *  - starting:  (video only) camera has started, but we are not recording yet. Button show 'Start recording'.\n *  - recording: Media is being recorded. Pause button visible if allowed. Main button shows 'Stop'. Countdown displayed.\n *  - paused:    If pause was pressed. Media recording paused, but resumable. Pause button changed to say 'resume'.\n *  - saving:    Media being uploaded. Progress indication shown. Pause button hidden if was visible.\n *  - recorded:  Recording and upload complete. The button then shows 'Record again'.\n *\n * @param {HTMLElement} widget the DOM node that is the top level of the whole recorder.\n * @param {(AudioSettings|VideoSettings)} mediaSettings information about the media type.\n * @param {Object} owner the object we are doing the recording for. Must provide three callback functions\n *                       showAlert notifyRecordingComplete notifyButtonStatesChanged.\n * @param {Object} uploadInfo object with fields uploadRepositoryId, draftItemId, contextId and maxUploadSize.\n * @constructor\n */\nfunction Recorder(widget, mediaSettings, owner, uploadInfo) {\n    /**\n     * @type {Recorder} reference to this recorder, for use in event handlers.\n     */\n    const recorder = this;\n\n    /**\n     * @type {MediaStream} during recording, the stream of incoming media.\n     */\n    let mediaStream = null;\n\n    /**\n     * @type {MediaRecorder} the recorder that is capturing stream.\n     */\n    let mediaRecorder = null;\n\n    /**\n     * @type {Blob[]} the chunks of data that have been captured so far during the current recording.\n     */\n    let chunks = [];\n\n    /**\n     * @type {number} number of bytes recorded so far, so we can auto-stop\n     * before hitting Moodle's file-size limit.\n     */\n    let bytesRecordedSoFar = 0;\n\n    /**\n     * @type {number} when paused, the time left in milliseconds, so we can auto-stop at the time limit.\n     */\n    let timeRemaining = 0;\n\n    /**\n     * @type {number} while recording, the time we reach the time-limit, so we can auto-stop then.\n     * This is milliseconds since Unix epoch, so comparable with Date.now().\n     */\n    let stopTime = 0;\n\n    /**\n     * @type {number} intervalID returned by setInterval() while the timer is running.\n     */\n    let countdownTicker = 0;\n\n    /**\n     * @type {object} The progress bar animation object.\n     */\n    let progressBarAnimation;\n\n    const button = widget.querySelector('button.qtype_recordrtc-main-button');\n    const pauseButton = widget.querySelector('.qtype_recordrtc-pause-button button');\n    const controlRow = widget.querySelector('.qtype_recordrtc-control-row');\n    const mediaElement = widget.querySelector('.qtype_recordrtc-media-player ' +\n        (mediaSettings.name === 'screen' ? 'video' : mediaSettings.name));\n    const noMediaPlaceholder = widget.querySelector('.qtype_recordrtc-no-recording-placeholder');\n    const timeDisplay = widget.querySelector('.qtype_recordrtc-time-left');\n    const progressBar = widget.querySelector('.qtype_recordrtc-time-left .qtype_recordrtc-timer-front');\n    const backTimeEnd = widget.querySelector('.qtype_recordrtc-time-left .qtype_recordrtc-timer-back span.timer-end');\n    const backtimeStart = widget.querySelector('.qtype_recordrtc-time-left .qtype_recordrtc-timer-back span.timer-start');\n    const frontTimeEnd = widget.querySelector('.qtype_recordrtc-time-left .qtype_recordrtc-timer-front span.timer-end');\n    const fronttimeStart = widget.querySelector('.qtype_recordrtc-time-left .qtype_recordrtc-timer-front span.timer-start');\n\n    widget.addEventListener('click', handleButtonClick);\n    this.uploadMediaToServer = uploadMediaToServer; // Make this method available.\n\n    /**\n     * Handles clicks on the start/stop and pause buttons.\n     *\n     * @param {Event} e\n     */\n    function handleButtonClick(e) {\n        const clickedButton = e.target.closest('button');\n        if (!clickedButton || clickedButton.classList.contains('close')) {\n            return; // It's not actually a button click or clicking a button to close the alert message.\n        }\n        e.preventDefault();\n        switch (widget.dataset.state) {\n            case 'new':\n            case 'recorded':\n                startRecording();\n                break;\n            case 'starting':\n                startSaving();\n                break;\n            case 'recording':\n                if (clickedButton === pauseButton) {\n                    pause();\n                } else {\n                    stopRecording();\n                }\n                break;\n            case 'paused':\n                if (clickedButton === pauseButton) {\n                    resume();\n                } else {\n                    stopRecording();\n                }\n                break;\n        }\n    }\n\n    /**\n     * Start recording (because the button was clicked).\n     */\n    function startRecording() {\n\n        // Hide error message.\n        const errorMessage = widget.querySelector('.alert.alert-block');\n        if (errorMessage) {\n            errorMessage.remove();\n        }\n\n        const videoElement = widget.querySelector('video');\n        if (videoElement && videoElement.classList.contains('d-none')) {\n            videoElement.classList.remove('d-none');\n        }\n\n        // Reset timer label.\n        setLabelForTimer(0, parseInt(widget.dataset.maxRecordingDuration));\n\n        if (mediaSettings.name === 'audio') {\n            mediaElement.parentElement.classList.add('hide');\n            noMediaPlaceholder.classList.add('hide');\n            timeDisplay.classList.remove('hide');\n\n        } else {\n            mediaElement.parentElement.classList.remove('hide');\n            noMediaPlaceholder.classList.add('hide');\n        }\n        pauseButton?.parentElement.classList.remove('hide');\n\n        // Change look of recording button.\n        button.classList.remove('btn-outline-danger');\n        button.classList.add('btn-danger');\n\n        // Disable other question buttons when current widget stared recording.\n        disableAllButtons();\n\n        // Empty the array containing the previously recorded chunks.\n        chunks = [];\n        bytesRecordedSoFar = 0;\n\n        // Normal case.\n        if (mediaSettings.name !== 'screen') {\n            navigator.mediaDevices.getUserMedia(mediaSettings.mediaConstraints)\n                .then(handleCaptureStarting)\n                .catch(handleCaptureFailed);\n            return;\n        }\n\n        // Screen recording requires both audio and the screen, and we need to get them both together.\n        const audioPromise = navigator.mediaDevices.getUserMedia({audio: true});\n        const screenPromise = navigator.mediaDevices.getDisplayMedia(mediaSettings.mediaConstraints);\n\n        // If the audioPromise is \"rejected\" (indicating that the user does not want to share their voice),\n        // we will proceed to record their screen without audio.\n        // Therefore, we will use Promise.allSettled instead of Promise.all.\n        Promise.allSettled([audioPromise, screenPromise]).then(combineAudioAndScreenRecording);\n    }\n\n    /**\n     * For starting screen recording, once we have both audio and video, combine them.\n     *\n     * @param {Object[]} results from the above Promise.allSettled call.\n     */\n    function combineAudioAndScreenRecording(results) {\n        const [audioData, screenData] = results;\n\n        if (screenData.status !== 'fulfilled') {\n            // If the user does not grant screen permission show warning popup.\n            handleCaptureFailed(screenData.reason);\n            return;\n        }\n        const screenStream = screenData.value;\n\n        // Prepare to handle if the user clicks the browser's \"Stop Sharing Screen\" button.\n        screenStream.getVideoTracks()[0].addEventListener('ended', handleStopSharing);\n\n        // Handle microphone.\n        if (audioData.status !== 'fulfilled') {\n            // We could not get audio. In this case, we just continue without audio,\n            // but put the message in the console in case we need to debug.\n            Log.debug(\"Could not capture audio. Continuing without. Reason: \" + audioData.reason);\n            handleCaptureStarting(screenStream);\n            return;\n        }\n        const audioStream = audioData.value;\n\n        // Merge the video track from the media stream with the audio track from the microphone stream\n        // and stop any unnecessary tracks to ensure that the recorded video has microphone sound.\n        const composedStream = new MediaStream();\n        screenStream.getTracks().forEach(function(track) {\n            if (track.kind === 'video') {\n                composedStream.addTrack(track);\n            } else {\n                track.stop();\n            }\n        });\n        audioStream.getAudioTracks().forEach(function(micTrack) {\n            composedStream.addTrack(micTrack);\n        });\n\n        handleCaptureStarting(composedStream);\n    }\n\n    /**\n     * Callback once getUserMedia has permission from the user to access the recording devices.\n     *\n     * @param {MediaStream} stream the stream to record.\n     */\n    function handleCaptureStarting(stream) {\n        mediaStream = stream;\n\n        // Setup the UI for during recording.\n        mediaElement.srcObject = stream;\n        mediaElement.muted = true;\n        switch (mediaSettings.name) {\n            case 'audio':\n                startSaving();\n                button.disabled = false;\n                button.focus();\n                break;\n\n            case 'video':\n                mediaElement.play();\n                mediaElement.controls = false;\n\n                widget.dataset.state = 'starting';\n                setButtonLabel('startrecording');\n                button.disabled = false;\n                button.focus();\n                widget.querySelector('.qtype_recordrtc-stop-button').disabled = false;\n                break;\n\n            case 'screen':\n                mediaElement.play();\n                mediaElement.controls = false;\n                startSaving();\n                widget.querySelector('.qtype_recordrtc-stop-button').disabled = false;\n                break;\n        }\n\n        // Make button clickable again, to allow starting/stopping recording.\n        if (pauseButton) {\n            pauseButton.disabled = false;\n        }\n    }\n\n    /**\n     * For recording types which show the media during recording,\n     * this starts the loop-back display, but does not start recording it yet.\n     */\n    function startSaving() {\n        // Initialize MediaRecorder events and start recording.\n        mediaRecorder = new MediaRecorder(mediaStream, getRecordingOptions());\n\n        mediaRecorder.ondataavailable = handleDataAvailable;\n        mediaRecorder.onpause = handleDataAvailable;\n        mediaRecorder.onstop = handleRecordingHasStopped;\n        mediaRecorder.start(1000); // Capture in one-second chunks. Firefox requires that.\n\n        widget.dataset.state = 'recording';\n        // Initialize and start the animation.\n        initProgressBarAnimation();\n        progressBarAnimation.play();\n        setButtonLabel('stoprecording');\n        startCountdownTimer();\n        if (isVideoRecording()) {\n            button.parentElement.classList.add('hide');\n            controlRow.classList.remove('hide');\n            controlRow.classList.add('d-flex');\n            timeDisplay.classList.remove('hide');\n        }\n    }\n\n    /**\n     * Callback that is called by the user clicking Stop screen sharing on the browser.\n     */\n    function handleStopSharing() {\n        if (widget.dataset.state === 'starting') {\n            widget.dataset.state = 'new';\n            mediaElement.parentElement.classList.add('hide');\n            noMediaPlaceholder.classList.remove('hide');\n            setButtonLabel('startsharescreen');\n            button.blur();\n        } else {\n            const controlEl = widget.querySelector('.qtype_recordrtc-control-row');\n            if (!controlEl.classList.contains('hide')) {\n                controlEl.querySelector('.qtype_recordrtc-stop-button').click();\n            }\n        }\n        enableAllButtons();\n    }\n\n    /**\n     * Function to initialise progress bar animation.\n     */\n    function initProgressBarAnimation() {\n        progressBarAnimation = progressBar.animate([\n            {clipPath: 'inset(0 0 0 0%)'},\n            {clipPath: 'inset(0 0 0 100%)'},\n        ], {\n            duration: widget.dataset.maxRecordingDuration * 1000,\n            fill: 'forwards',\n            delay: 0,\n        });\n    }\n\n    /**\n     * Callback that is called by the media system for each Chunk of data.\n     *\n     * @param {BlobEvent} event\n     */\n    function handleDataAvailable(event) {\n        if (!event.data) {\n            return; // It seems this can happen around pausing.\n        }\n\n        // Check there is space to store the next chunk, and if not stop.\n        bytesRecordedSoFar += event.data.size;\n        if (uploadInfo.maxUploadSize >= 0 && bytesRecordedSoFar >= uploadInfo.maxUploadSize) {\n\n            // Extra check to avoid alerting twice.\n            if (!localStorage.getItem('alerted')) {\n                localStorage.setItem('alerted', 'true');\n                stopRecording();\n                owner.showAlert('nearingmaxsize');\n\n            } else {\n                localStorage.removeItem('alerted');\n            }\n        }\n\n        // Store the next chunk of data.\n        chunks.push(event.data);\n\n        // Notify form-change-checker that there is now unsaved data.\n        // But, don't do this in question preview where it is just annoying.\n        if (typeof M.core_formchangechecker !== 'undefined' &&\n            !window.location.pathname.endsWith('/question/bank/previewquestion/preview.php')) {\n            M.core_formchangechecker.set_form_changed();\n        }\n    }\n\n    /**\n     * Pause recording.\n     */\n    function pause() {\n        // Stop the count-down timer.\n        stopCountdownTimer();\n        setPauseButtonLabel('resume');\n        mediaRecorder.pause();\n        widget.dataset.state = 'paused';\n        // Pause animate.\n        toggleProgressbarState();\n    }\n\n    /**\n     * Continue recording.\n     */\n    function resume() {\n        // Stop the count-down timer.\n        resumeCountdownTimer();\n        widget.dataset.state = 'recording';\n        setPauseButtonLabel('pause');\n        mediaRecorder.resume();\n        // Resume animate.\n        toggleProgressbarState();\n    }\n\n    /**\n     * Start recording (because the button was clicked or because we have reached a limit).\n     */\n    function stopRecording() {\n        // Disable the button while things change.\n        button.disabled = true;\n\n        // Stop the count-down timer.\n        stopCountdownTimer();\n\n        // Update the button.\n        button.classList.remove('btn-danger');\n        button.classList.add('btn-outline-danger');\n        if (pauseButton) {\n            setPauseButtonLabel('pause');\n            pauseButton.parentElement.classList.add('hide');\n        }\n\n        // Stop animate.\n        progressBarAnimation.cancel();\n\n        // Ask the recording to stop.\n        mediaRecorder.stop();\n\n        // Also stop each individual MediaTrack.\n        const tracks = mediaStream.getTracks();\n        for (let i = 0; i < tracks.length; i++) {\n            tracks[i].stop();\n        }\n    }\n\n    /**\n     * Callback that is called by the media system once recording has finished.\n     */\n    function handleRecordingHasStopped() {\n        if (widget.dataset.state === 'new') {\n            // This can happens if an error occurs when recording is starting. Do nothing.\n            return;\n        }\n\n        const blob = new Blob(chunks, {type: mediaRecorder.mimeType});\n        // Make blob seekable.\n        makeBlobSeekable(blob).then(newBlob => {\n            // Set source of the media player.\n            mediaElement.srcObject = null;\n            mediaElement.src = URL.createObjectURL(newBlob);\n\n            // Show audio player with controls enabled, and unmute.\n            mediaElement.muted = false;\n            mediaElement.controls = true;\n            mediaElement.parentElement.classList.remove('hide');\n            noMediaPlaceholder.classList.add('hide');\n            mediaElement.focus();\n\n            if (mediaSettings.name === 'audio') {\n                timeDisplay.classList.add('hide');\n\n            } else {\n                button.parentElement.classList.remove('hide');\n                controlRow.classList.add('hide');\n                controlRow.classList.remove('d-flex');\n            }\n\n            // Ensure the button while things change.\n            button.disabled = true;\n            button.classList.remove('btn-danger');\n            button.classList.add('btn-outline-danger');\n            widget.dataset.state = 'recorded';\n\n            if (chunks.length > 0) {\n                owner.notifyRecordingComplete(recorder);\n            }\n        });\n    }\n\n    /**\n     * From the given blob, use EBML library to make it seekable.\n     *\n     * @param {Blob} originalBlob The recorded blob that need to be adjusted.\n     * @returns {Promise} The seekable blob promise.\n     */\n    async function makeBlobSeekable(originalBlob) {\n        const ebml = await getEBMLJs();\n        return new Promise((resolve) => {\n            if (!isVideoRecording()) {\n                // We only make changes with video recording.\n                resolve(originalBlob);\n                return;\n            }\n            const reader = new ebml.Reader();\n            const decoder = new ebml.Decoder();\n            const tools = ebml.tools;\n            const fileReader = new FileReader();\n            fileReader.onload = function() {\n                try {\n                    // Try to decode.\n                    const ebmlElms = decoder.decode(this.result);\n                    ebmlElms.forEach(function(element) {\n                        reader.read(element);\n                    });\n                    reader.stop();\n                    // Make seekable.\n                    const refinedMetadataBuf = tools.makeMetadataSeekable(reader.metadatas, reader.duration, reader.cues);\n                    const body = this.result.slice(reader.metadataSize);\n                    const seekableBlob = new Blob([refinedMetadataBuf, body], {type: mediaRecorder.mimeType});\n                    resolve(seekableBlob);\n                } catch (e) {\n                    // The browser can not make video seekable.\n                    resolve(originalBlob);\n                }\n            };\n            // Read blob.\n            fileReader.readAsArrayBuffer(originalBlob);\n        });\n    }\n\n    /**\n     * Helper to get the ebml library.\n     *\n     * @returns {Promise<*>} access to the ebml library.\n     */\n    async function getEBMLJs() {\n        return await import(M.cfg.wwwroot + '/question/type/recordrtc/js/ebml/EBML.min.js');\n    }\n\n    /**\n     * Function that handles errors from the recorder.\n     *\n     * @param {DOMException} error\n     */\n    function handleCaptureFailed(error) {\n        Log.debug('Audio/video/screen question: error received');\n        Log.debug(error);\n\n        setPlaceholderMessage('recordingfailed');\n        setButtonLabel('recordagainx');\n        button.classList.remove('btn-danger');\n        button.classList.add('btn-outline-danger');\n        widget.dataset.state = 'new';\n        // Hide time display.\n        timeDisplay.classList.add('hide');\n\n        if (mediaRecorder && mediaRecorder.state !== 'inactive') {\n            mediaRecorder.stop();\n        }\n\n        // Changes 'CertainError' -> 'gumcertain' to match language string names.\n        const stringName = 'gum' + error.name.replace('Error', '').toLowerCase();\n\n        owner.showAlert(stringName);\n        enableAllButtons();\n    }\n\n    /**\n     * Start the countdown timer.\n     */\n    function startCountdownTimer() {\n        timeRemaining = widget.dataset.maxRecordingDuration * 1000;\n        resumeCountdownTimer();\n        updateTimerDisplay();\n    }\n\n    /**\n     * Stop the countdown timer.\n     */\n    function stopCountdownTimer() {\n        timeRemaining = stopTime - Date.now();\n        if (countdownTicker !== 0) {\n            clearInterval(countdownTicker);\n            countdownTicker = 0;\n        }\n    }\n\n    /**\n     * Start or resume the countdown timer.\n     */\n    function resumeCountdownTimer() {\n        stopTime = Date.now() + timeRemaining;\n        if (countdownTicker === 0) {\n            countdownTicker = setInterval(updateTimerDisplay, 100);\n        }\n    }\n\n    /**\n     * Update the countdown timer, and stop recording if we have reached 0.\n     */\n    function updateTimerDisplay() {\n        const millisecondsRemaining = stopTime - Date.now();\n        const secondsRemaining = Math.round(millisecondsRemaining / 1000);\n        const secondsStart = widget.dataset.maxRecordingDuration - secondsRemaining;\n        // Set time label for elements.\n        setLabelForTimer(secondsStart, secondsRemaining);\n        if (millisecondsRemaining <= 0) {\n            stopRecording();\n        }\n    }\n\n    /**\n     * Get time label for timer.\n     *\n     * @param {number} seconds The time in seconds.\n     * @return {string} The label for timer. e.g. '00:00' or '10:00'.\n     */\n    function getTimeLabelForTimer(seconds) {\n        const secs = seconds % 60;\n        const mins = Math.round((seconds - secs) / 60);\n\n        return M.util.get_string('timedisplay', 'qtype_recordrtc',\n            {mins: pad(mins), secs: pad(secs)});\n    }\n\n    /**\n     * Set time label for timer.\n     * We need to update the labels for both the timer back(whose background color is white) and\n     * timer front (with blue background) to create a text effect that contrasts with the background color.\n     *\n     * @param {Number} secondsStart The second start. e.g: With duration 1 minute\n     * secondsStart will start from 0 and increase up to 60.\n     * @param {Number} secondsRemaining The second remaining. e.g: With duration 1 minute\n     * secondsRemaining will decrease from 60 to 0.\n     */\n    function setLabelForTimer(secondsStart, secondsRemaining) {\n        // Set time label for timer back.\n        backTimeEnd.innerText = getTimeLabelForTimer(secondsRemaining);\n        backtimeStart.innerText = getTimeLabelForTimer(secondsStart);\n        // Set time label for timer front.\n        frontTimeEnd.innerText = getTimeLabelForTimer(secondsRemaining);\n        fronttimeStart.innerText = getTimeLabelForTimer(secondsStart);\n    }\n\n    /**\n     * Zero-pad a string to be at least two characters long.\n     *\n     * @param {number} val e.g. 1 or 10\n     * @return {string} e.g. '01' or '10'.\n     */\n    function pad(val) {\n        const valString = val + '';\n\n        if (valString.length < 2) {\n            return '0' + valString;\n        } else {\n            return '' + valString;\n        }\n    }\n\n    /**\n     * Trigger the upload of the recorded media back to Moodle.\n     */\n    async function uploadMediaToServer() {\n        setButtonLabel('uploadpreparing');\n\n        if (widget.dataset.convertToMp3) {\n            const mp3DataBlob = await convertOggToMp3(mediaElement.src);\n            mediaElement.src = URL.createObjectURL(mp3DataBlob);\n            uploadBlobToRepository(mp3DataBlob, widget.dataset.recordingFilename.replace(/\\.ogg$/, '.mp3'));\n        } else {\n            // First we need to get the media data from the media element.\n            const oggDataBlob = await fetchOggData(mediaElement.src, 'blob');\n            uploadBlobToRepository(oggDataBlob, widget.dataset.recordingFilename);\n        }\n    }\n\n    /**\n     * Convert audio data to MP3.\n     *\n     * @param {string} sourceUrl URL from which to fetch the Ogg audio file to convert.\n     * @returns {Promise<Blob>}\n     */\n    async function convertOggToMp3(sourceUrl) {\n        const lamejs = await getLameJs();\n        const oggData = await fetchOggData(sourceUrl, 'arraybuffer');\n        const audioBuffer = await (new AudioContext()).decodeAudioData(oggData);\n        const [left, right] = getRawAudioDataFromBuffer(audioBuffer);\n        return await createMp3(lamejs, audioBuffer.numberOfChannels, audioBuffer.sampleRate, left, right);\n    }\n\n    /**\n     * Helper to wrap loading the lamejs library.\n     *\n     * @returns {Promise<*>} access to the lamejs library.\n     */\n    async function getLameJs() {\n        return await import(M.cfg.wwwroot + '/question/type/recordrtc/js/lamejs@1.2.1a-7-g582bbba/lame.min.js');\n    }\n\n    /**\n     * Load Ogg data from a URL and return as an ArrayBuffer or a Blob.\n     *\n     * @param {string} sourceUrl URL from which to fetch the Ogg audio data.\n     * @param {XMLHttpRequestResponseType} responseType 'arraybuffer' or 'blob'.\n     * @returns {Promise<ArrayBuffer|Blob>} the audio data in the requested structure.\n     */\n    function fetchOggData(sourceUrl, responseType) {\n        return new Promise((resolve) => {\n            const fetchRequest = new XMLHttpRequest();\n            fetchRequest.open('GET', sourceUrl);\n            fetchRequest.responseType = responseType;\n            fetchRequest.addEventListener('load', () => {\n                resolve(fetchRequest.response);\n            });\n            fetchRequest.send();\n        });\n    }\n\n    /**\n     * Extract the raw sample data from an AudioBuffer.\n     *\n     * @param {AudioBuffer} audioIn an audio buffer, e.g. from a call to decodeAudioData.\n     * @returns {Int16Array[]} for each audio channel, a Int16Array of the samples.\n     */\n    function getRawAudioDataFromBuffer(audioIn) {\n        const channelData = [];\n\n        for (let channel = 0; channel < audioIn.numberOfChannels; channel++) {\n            const rawChannelData = audioIn.getChannelData(channel);\n            channelData[channel] = new Int16Array(audioIn.length);\n            for (let i = 0; i < audioIn.length; i++) {\n                // This is not the normal code given for this conversion (which can be\n                // found in git history) but this is 10x faster, and surely good enough.\n                channelData[channel][i] = rawChannelData[i] * 0x7FFF;\n            }\n        }\n\n        return channelData;\n    }\n\n    /**\n     * Convert some audio data to MP3.\n     *\n     * @param {*} lamejs lamejs library from getLameJs().\n     * @param {int} channels number of audio channels (1 or 2 supported).\n     * @param {int} sampleRate sample rate of the audio to encode.\n     * @param {Int16Array} left audio data for the left or only channel.\n     * @param {Int16Array|null} right audio data for the right channel, if any.\n     * @returns {Blob} representing an MP3 file.\n     */\n    async function createMp3(lamejs, channels, sampleRate, left, right = null) {\n        const buffer = [];\n        const mp3enc = new lamejs.Mp3Encoder(channels, sampleRate, mediaSettings.bitRate / 1000);\n        let remaining = left.length;\n        const samplesPerFrame = 1152;\n        let mp3buf;\n\n        await setPreparingPercent(0, left.length);\n        for (let i = 0; remaining >= samplesPerFrame; i += samplesPerFrame) {\n            if (channels === 1) {\n                const mono = left.subarray(i, i + samplesPerFrame);\n                mp3buf = mp3enc.encodeBuffer(mono);\n            } else {\n                const leftChunk = left.subarray(i, i + samplesPerFrame);\n                const rightChunk = right.subarray(i, i + samplesPerFrame);\n                mp3buf = mp3enc.encodeBuffer(leftChunk, rightChunk);\n            }\n            if (mp3buf.length > 0) {\n                buffer.push(mp3buf);\n            }\n            remaining -= samplesPerFrame;\n            if (i % (10 * samplesPerFrame) === 0) {\n                await setPreparingPercent(i, left.length);\n            }\n        }\n        const d = mp3enc.flush();\n        if (d.length > 0) {\n            buffer.push(new Int8Array(d));\n        }\n        await setPreparingPercent(left.length, left.length);\n\n        return new Blob(buffer, {type: \"audio/mp3\"});\n    }\n\n    /**\n     * Set the label on the upload button to a progress message including a percentage.\n     *\n     * @param {number} current number done so far.\n     * @param {number} total number to do in total.\n     */\n    async function setPreparingPercent(current, total) {\n        setButtonLabel('uploadpreparingpercent', Math.round(100 * current / total));\n        // Next like is a hack to ensure the screen acutally updates.\n        await new Promise(resolve => requestAnimationFrame(resolve));\n    }\n\n    /**\n     * Upload the audio file to the Moodle draft file repository.\n     *\n     * @param {Blob} blob data to upload.\n     * @param {string} recordingFilename the filename to use for the uplaod.\n     */\n    function uploadBlobToRepository(blob, recordingFilename) {\n\n        // Create FormData to send to PHP filepicker-upload script.\n        const formData = new FormData();\n        formData.append('repo_upload_file', blob, recordingFilename);\n        formData.append('sesskey', M.cfg.sesskey);\n        formData.append('repo_id', uploadInfo.uploadRepositoryId);\n        formData.append('itemid', uploadInfo.draftItemId);\n        formData.append('savepath', '/');\n        formData.append('ctx_id', uploadInfo.contextId);\n        formData.append('overwrite', '1');\n\n        const uploadRequest = new XMLHttpRequest();\n        uploadRequest.addEventListener('readystatechange', handleUploadReadyStateChanged);\n        uploadRequest.upload.addEventListener('progress', handleUploadProgress);\n        uploadRequest.addEventListener('error', handleUploadError);\n        uploadRequest.addEventListener('abort', handleUploadAbort);\n        uploadRequest.open('POST', M.cfg.wwwroot + '/repository/repository_ajax.php?action=upload');\n        uploadRequest.send(formData);\n    }\n\n    /**\n     * Callback for when the upload completes.\n     * @param {ProgressEvent} e\n     */\n    function handleUploadReadyStateChanged(e) {\n        const uploadRequest = e.target;\n        if (uploadRequest.readyState !== 4) {\n            return; // Not finished yet. We will get more of these events when it is.\n        }\n\n        const response = JSON.parse(uploadRequest.responseText);\n        if (response.errorcode) {\n            handleUploadError(); // Moodle sends back errors with a 200 status code for some reason!\n        }\n\n        if (uploadRequest.status === 200) {\n            // When request finished and successful.\n            setButtonLabel('recordagainx');\n            button.classList.remove('btn-outline-danger');\n            enableAllButtons();\n        } else if (uploadRequest.status === 404) {\n            setPlaceholderMessage('uploadfailed404');\n            enableAllButtons();\n        }\n    }\n\n    /**\n     * Callback for updating the upload progress.\n     * @param {ProgressEvent} e\n     */\n    function handleUploadProgress(e) {\n        setButtonLabel('uploadprogress', Math.round(e.loaded / e.total * 100) + '%');\n    }\n\n    /**\n     * Callback for when the upload fails with an error.\n     */\n    function handleUploadError() {\n        setPlaceholderMessage('uploadfailed');\n        enableAllButtons();\n    }\n\n    /**\n     * Callback for when the upload fails with an error.\n     */\n    function handleUploadAbort() {\n        setPlaceholderMessage('uploadaborted');\n        enableAllButtons();\n    }\n\n    /**\n     * Change the label on the start/stop button.\n     *\n     * @param {string} langString\n     * @param {string|null} [a] optional variable to populate placeholder with\n     */\n    function setButtonLabel(langString, a) {\n        if (a === undefined) {\n            // Seemingly unnecessary space inside the span is needed for screen-readers, and it must be a non-breaking space.\n            a = '<span class=\"sr-only\">&nbsp;' + widget.dataset.widgetName + '</span>';\n        }\n        button.innerHTML = M.util.get_string(langString, 'qtype_recordrtc', a);\n    }\n\n    /**\n     * Change the label on the pause button.\n     *\n     * @param {string} langString\n     */\n    function setPauseButtonLabel(langString) {\n        pauseButton.innerText = M.util.get_string(langString, 'qtype_recordrtc');\n    }\n\n    /**\n     * Display a message in the upload progress area.\n     *\n     * @param {string} langString\n     */\n    function setPlaceholderMessage(langString) {\n        noMediaPlaceholder.textContent = M.util.get_string(langString, 'qtype_recordrtc');\n        mediaElement.parentElement.classList.add('hide');\n        noMediaPlaceholder.classList.remove('hide');\n    }\n\n    /**\n     * Select best options for the recording codec.\n     *\n     * @returns {Object}\n     */\n    function getRecordingOptions() {\n        const options = {};\n\n        // Get the relevant bit rates from settings.\n        if (mediaSettings.name === 'audio') {\n            options.audioBitsPerSecond = mediaSettings.bitRate;\n        } else if (isVideoRecording()) {\n            options.videoBitsPerSecond = mediaSettings.bitRate;\n            options.videoWidth = mediaSettings.width;\n            options.videoHeight = mediaSettings.height;\n\n            // Go through our list of mimeTypes, and take the first one that will work.\n            for (let i = 0; i < mediaSettings.mimeTypes.length; i++) {\n                if (MediaRecorder.isTypeSupported(mediaSettings.mimeTypes[i])) {\n                    options.mimeType = mediaSettings.mimeTypes[i];\n                    break;\n                }\n            }\n        }\n\n        return options;\n    }\n\n    /**\n     * Enable all buttons in the question.\n     */\n    function enableAllButtons() {\n        disableOrEnableButtons(true);\n        owner.notifyButtonStatesChanged();\n    }\n\n    /**\n     * Disable all buttons in the question.\n     */\n    function disableAllButtons() {\n        disableOrEnableButtons(false);\n    }\n\n    /**\n     * Disables/enables other question buttons when current widget started recording/finished recording.\n     *\n     * @param {boolean} enabled true if the button should be enabled.\n     */\n    function disableOrEnableButtons(enabled = false) {\n        document.querySelectorAll('.que.recordrtc').forEach(record => {\n            record.querySelectorAll('button, input[type=submit], input[type=button]').forEach(button => {\n                button.disabled = !enabled;\n            });\n        });\n    }\n\n    /**\n     * Pause/resume the progressbar state.\n     */\n    function toggleProgressbarState() {\n        const animationState = progressBarAnimation.playState || 'running';\n        if (animationState === 'running') {\n            progressBarAnimation.pause();\n        } else {\n            progressBarAnimation.play();\n        }\n    }\n\n    /**\n     * Check if media setting is video or screen.\n     */\n    function isVideoRecording() {\n        return mediaSettings.name === 'video' || mediaSettings.name === 'screen';\n    }\n}\n\n/**\n * Object that controls the settings for recording audio.\n *\n * @param {string} bitRate desired audio bitrate.\n * @constructor\n */\nfunction AudioSettings(bitRate) {\n    this.name = 'audio';\n    this.bitRate = parseInt(bitRate, 10);\n    this.mediaConstraints = {\n        audio: true\n    };\n    this.mimeTypes = [\n        'audio/webm;codecs=opus',\n        'audio/ogg;codecs=opus'\n    ];\n}\n\n/**\n * Object that controls the settings for recording video.\n *\n * @param {string} bitRate desired video bitrate.\n * @param {string} width desired width.\n * @param {string} height desired height.\n * @constructor\n */\nfunction VideoSettings(bitRate, width, height) {\n    this.name = 'video';\n    this.bitRate = parseInt(bitRate, 10);\n    this.width = parseInt(width, 10);\n    this.height = parseInt(height, 10);\n    this.mediaConstraints = {\n        audio: true,\n        video: {\n            width: {ideal: this.width},\n            height: {ideal: this.height}\n        }\n    };\n    this.mimeTypes = [\n        'video/webm;codecs=vp9,opus',\n        'video/webm;codecs=h264,opus',\n        'video/webm;codecs=vp8,opus'\n    ];\n}\n\n/**\n * Object that controls the settings for recording screen.\n *\n * @param {string} bitRate desired screen bitrate.\n * @param {string} width desired width.\n * @param {string} height desired height.\n * @constructor\n */\nfunction ScreenSettings(bitRate, width, height) {\n    this.name = 'screen';\n    this.bitRate = parseInt(bitRate, 10);\n    this.width = parseInt(width, 10);\n    this.height = parseInt(height, 10);\n    this.mediaConstraints = {\n        audio: true,\n        systemAudio: 'exclude',\n        video: {\n            displaySurface: 'monitor',\n            frameRate: {ideal: 24},\n            // Currently, Safari does not support ideal constraints for width and height with screen sharing feature.\n            // It may be supported in version 16.4.\n            width: {max: this.width},\n            height: {max: this.height},\n        }\n    };\n\n    // We use vp8 as the default codec. If it is not supported, we will switch to another codec.\n    this.mimeTypes = [\n        'video/webm;codecs=vp8,opus',\n        'video/webm;codecs=vp9,opus',\n        'video/webm;codecs=h264,opus',\n    ];\n}\n\n/**\n * Represents one record audio or video question.\n *\n * @param {string} questionId id of the outer question div.\n * @param {Object} settings like audio bit rate.\n * @constructor\n */\nfunction RecordRtcQuestion(questionId, settings) {\n    const questionDiv = document.getElementById(questionId);\n\n    // Check if the RTC API can work here.\n    const result = checkCanWork();\n    if (result === 'nothttps') {\n        questionDiv.querySelector('.https-warning').classList.remove('hide');\n        return;\n    } else if (result === 'nowebrtc') {\n        questionDiv.querySelector('.no-webrtc-warning').classList.remove('hide');\n        return;\n    }\n\n    // Make the callback functions available.\n    this.showAlert = showAlert;\n    this.notifyRecordingComplete = notifyRecordingComplete;\n    this.notifyButtonStatesChanged = setSubmitButtonState;\n    const thisQuestion = this;\n\n    // We may have more than one widget in a question.\n    questionDiv.querySelectorAll('.qtype_recordrtc-audio-widget, .qtype_recordrtc-video-widget, .qtype_recordrtc-screen-widget')\n        .forEach(function(widget) {\n            // Get the appropriate options.\n            let typeInfo;\n            switch (widget.dataset.mediaType) {\n                case 'audio':\n                    typeInfo = new AudioSettings(settings.audioBitRate);\n                    break;\n                case 'screen':\n                    typeInfo = new ScreenSettings(settings.screenBitRate, settings.screenWidth, settings.screenHeight);\n                    break;\n                default:\n                    typeInfo = new VideoSettings(settings.videoBitRate, settings.videoWidth, settings.videoHeight);\n                    break;\n            }\n\n            // Create the recorder.\n            new Recorder(widget, typeInfo, thisQuestion, settings);\n            return 'Not used';\n        });\n    setSubmitButtonState();\n\n    /**\n     * Set the state of the question's submit button.\n     *\n     * If any recorder does not yet have a recording, then disable the button.\n     * Otherwise, enable it.\n     */\n    function setSubmitButtonState() {\n        let anyRecorded = false;\n        questionDiv.querySelectorAll('.qtype_recordrtc-audio-widget, .qtype_recordrtc-video-widget, .qtype_recordrtc-screen-widget')\n            .forEach(function(widget) {\n                if (widget.dataset.state === 'recorded') {\n                    anyRecorded = true;\n                }\n            });\n\n        // Before 4.2, the submitButton is a input tag.\n        // After 4.2, the submitButton is a button tag.\n        // So we are using class and submit attribute as a selector.\n        const submitButton = questionDiv.querySelector('.im-controls .submit[type=submit]');\n        if (submitButton) {\n            submitButton.disabled = !anyRecorded;\n        }\n    }\n\n    /**\n     * Show a modal alert.\n     *\n     * @param {string} subject Subject is the content of the alert (which error the alert is for).\n     * @return {Promise}\n     */\n    function showAlert(subject) {\n        return ModalFactory.create({\n            type: ModalFactory.types.ALERT,\n            title: M.util.get_string(subject + '_title', 'qtype_recordrtc'),\n            body: M.util.get_string(subject, 'qtype_recordrtc'),\n        }).then(function(modal) {\n            modal.show();\n            return modal;\n        });\n    }\n\n    /**\n     * Callback called when the recording is completed.\n     *\n     * @param {Recorder} recorder the recorder.\n     */\n    function notifyRecordingComplete(recorder) {\n        recorder.uploadMediaToServer();\n    }\n}\n\n/**\n * Setup video playback, catching errors if the device can't playback this format.\n *\n * @param {string} questionId id of the outer question div.\n */\nfunction addPlaybackErrorHandlingToVideoElements(questionId) {\n    const questionDiv = document.getElementById(questionId);\n    // Retrieve all video and screen widgets.\n    const mediaElements = questionDiv.querySelectorAll('.qtype_recordrtc-screen-widget, .qtype_recordrtc-video-widget');\n\n    // We only need to do some if any have a recording.\n    if (!Array.prototype.some.call(mediaElements, media => (media.querySelector('video:not([data-source=\"\"])') !== null))) {\n        return;\n    }\n\n    // Load the template once, before we use the hTML.\n    Templates.renderForPromise('core/notification_error', {\n            closebutton: true,\n            announce: true,\n            message: questionDiv.querySelector(\n                '.qtype_recordrtc-video-widget, .qtype_recordrtc-screen-widget').dataset.errorMessage,\n        }\n    ).then(({html}) => {\n        // Loop through the mediaElements list.\n        mediaElements.forEach(widget => {\n            const videoElement = widget.querySelector('video');\n\n            // Just handle the case when the video has been recorded.\n            if (videoElement.dataset.source === '') {\n                return;\n            }\n\n            const buttonElement = widget.querySelector('button.qtype_recordrtc-main-button[disabled]');\n\n            const sourceElement = document.createElement('source');\n            sourceElement.addEventListener('error', () => {\n                // Append error template into element.\n                Templates.appendNodeContents(widget.querySelector('.qtype_recordrtc-media-player'), html, '');\n                if (buttonElement) {\n                    buttonElement.disabled = false;\n                }\n            });\n\n            videoElement.addEventListener('loadeddata', () => {\n                // Show video element.\n                videoElement.classList.remove('d-none');\n                if (buttonElement) {\n                    buttonElement.disabled = false;\n                }\n            });\n\n            sourceElement.setAttribute('src', videoElement.dataset.source);\n            videoElement.appendChild(sourceElement);\n        });\n    }).catch((error) => {\n        Log.debug(\"Could not load error template\");\n        Log.debug(error);\n    });\n}\n\n/**\n * Initialise a record audio or video question.\n *\n * @param {string} questionId id of the outer question div.\n * @param {Object} settings like audio bit rate.\n */\nfunction init(questionId, settings) {\n    M.util.js_pending('init-' + questionId);\n    new RecordRtcQuestion(questionId, settings);\n    M.util.js_complete('init-' + questionId);\n}\n\nexport {\n    init,\n    addPlaybackErrorHandlingToVideoElements\n};\n"],"names":["questionId","questionDiv","document","getElementById","mediaElements","querySelectorAll","Array","prototype","some","call","media","querySelector","renderForPromise","closebutton","announce","message","dataset","errorMessage","then","_ref","html","forEach","widget","videoElement","source","buttonElement","sourceElement","createElement","addEventListener","appendNodeContents","disabled","classList","remove","setAttribute","appendChild","catch","error","debug","settings","M","util","js_pending","RecordRtcQuestion","js_complete","Recorder","mediaSettings","owner","uploadInfo","recorder","this","progressBarAnimation","mediaStream","mediaRecorder","chunks","bytesRecordedSoFar","timeRemaining","stopTime","countdownTicker","button","pauseButton","controlRow","mediaElement","name","noMediaPlaceholder","timeDisplay","progressBar","backTimeEnd","backtimeStart","frontTimeEnd","fronttimeStart","combineAudioAndScreenRecording","results","audioData","screenData","status","handleCaptureFailed","reason","screenStream","value","getVideoTracks","handleStopSharing","handleCaptureStarting","audioStream","composedStream","MediaStream","getTracks","track","kind","addTrack","stop","getAudioTracks","micTrack","stream","srcObject","muted","startSaving","focus","play","controls","state","setButtonLabel","MediaRecorder","options","audioBitsPerSecond","bitRate","isVideoRecording","videoBitsPerSecond","videoWidth","width","videoHeight","height","i","mimeTypes","length","isTypeSupported","mimeType","getRecordingOptions","ondataavailable","handleDataAvailable","onpause","onstop","handleRecordingHasStopped","start","animate","clipPath","duration","maxRecordingDuration","fill","delay","resumeCountdownTimer","updateTimerDisplay","parentElement","add","blur","controlEl","contains","click","enableAllButtons","event","data","size","maxUploadSize","localStorage","getItem","removeItem","setItem","stopRecording","showAlert","push","core_formchangechecker","window","location","pathname","endsWith","set_form_changed","stopCountdownTimer","setPauseButtonLabel","cancel","tracks","originalBlob","ebml","cfg","wwwroot","getEBMLJs","Promise","resolve","reader","Reader","decoder","Decoder","tools","fileReader","FileReader","onload","decode","result","element","read","refinedMetadataBuf","makeMetadataSeekable","metadatas","cues","body","slice","metadataSize","seekableBlob","Blob","type","e","readAsArrayBuffer","makeBlobSeekable","newBlob","src","URL","createObjectURL","notifyRecordingComplete","setPlaceholderMessage","stringName","replace","toLowerCase","Date","now","clearInterval","setInterval","millisecondsRemaining","secondsRemaining","Math","round","setLabelForTimer","getTimeLabelForTimer","seconds","secs","mins","get_string","pad","secondsStart","innerText","val","valString","fetchOggData","sourceUrl","responseType","fetchRequest","XMLHttpRequest","open","response","send","setPreparingPercent","current","total","requestAnimationFrame","uploadBlobToRepository","blob","recordingFilename","formData","FormData","append","sesskey","uploadRepositoryId","draftItemId","contextId","uploadRequest","handleUploadReadyStateChanged","upload","handleUploadProgress","handleUploadError","handleUploadAbort","target","readyState","JSON","parse","responseText","errorcode","loaded","langString","a","undefined","widgetName","innerHTML","textContent","disableOrEnableButtons","notifyButtonStatesChanged","enabled","record","toggleProgressbarState","playState","pause","clickedButton","closest","preventDefault","parseInt","disableAllButtons","navigator","mediaDevices","getUserMedia","mediaConstraints","audioPromise","audio","screenPromise","getDisplayMedia","allSettled","startRecording","resume","uploadMediaToServer","convertToMp3","mp3DataBlob","lamejs","getLameJs","oggData","audioBuffer","AudioContext","decodeAudioData","left","right","audioIn","channelData","channel","numberOfChannels","rawChannelData","getChannelData","Int16Array","getRawAudioDataFromBuffer","channels","sampleRate","buffer","mp3enc","Mp3Encoder","remaining","samplesPerFrame","mp3buf","mono","subarray","encodeBuffer","leftChunk","rightChunk","d","flush","Int8Array","createMp3","convertOggToMp3","AudioSettings","VideoSettings","video","ideal","ScreenSettings","systemAudio","displaySurface","frameRate","max","protocol","host","subject","ModalFactory","create","types","ALERT","title","modal","show","setSubmitButtonState","thisQuestion","anyRecorded","submitButton","typeInfo","mediaType","audioBitRate","screenBitRate","screenWidth","screenHeight","videoBitRate"],"mappings":"uQAkrCiDA,kBACvCC,YAAcC,SAASC,eAAeH,YAEtCI,cAAgBH,YAAYI,iBAAiB,qEAG9CC,MAAMC,UAAUC,KAAKC,KAAKL,eAAeM,OAAiE,OAAvDA,MAAMC,cAAc,2DAKlEC,iBAAiB,0BAA2B,CAC9CC,aAAa,EACbC,UAAU,EACVC,QAASd,YAAYU,cACjB,iEAAiEK,QAAQC,eAEnFC,MAAKC,WAACC,KAACA,WAELhB,cAAciB,SAAQC,eACZC,aAAeD,OAAOX,cAAc,YAGN,KAAhCY,aAAaP,QAAQQ,oBAInBC,cAAgBH,OAAOX,cAAc,gDAErCe,cAAgBxB,SAASyB,cAAc,UAC7CD,cAAcE,iBAAiB,SAAS,wBAE1BC,mBAAmBP,OAAOX,cAAc,iCAAkCS,KAAM,IACtFK,gBACAA,cAAcK,UAAW,MAIjCP,aAAaK,iBAAiB,cAAc,KAExCL,aAAaQ,UAAUC,OAAO,UAC1BP,gBACAA,cAAcK,UAAW,MAIjCJ,cAAcO,aAAa,MAAOV,aAAaP,QAAQQ,QACvDD,aAAaW,YAAYR,qBAE9BS,OAAOC,qBACFC,MAAM,8CACNA,MAAMD,kCAUJpC,WAAYsC,UACtBC,EAAEC,KAAKC,WAAW,QAAUzC,gBACxB0C,kBAAkB1C,WAAYsC,UAClCC,EAAEC,KAAKG,YAAY,QAAU3C,gYAnqCxB4C,SAAStB,OAAQuB,cAAeC,MAAOC,kBAItCC,SAAWC,SA0CbC,qBArCAC,YAAc,KAKdC,cAAgB,KAKhBC,OAAS,GAMTC,mBAAqB,EAKrBC,cAAgB,EAMhBC,SAAW,EAKXC,gBAAkB,QAOhBC,OAASpC,OAAOX,cAAc,sCAC9BgD,YAAcrC,OAAOX,cAAc,wCACnCiD,WAAatC,OAAOX,cAAc,gCAClCkD,aAAevC,OAAOX,cAAc,kCACd,WAAvBkC,cAAciB,KAAoB,QAAUjB,cAAciB,OACzDC,mBAAqBzC,OAAOX,cAAc,6CAC1CqD,YAAc1C,OAAOX,cAAc,8BACnCsD,YAAc3C,OAAOX,cAAc,2DACnCuD,YAAc5C,OAAOX,cAAc,yEACnCwD,cAAgB7C,OAAOX,cAAc,2EACrCyD,aAAe9C,OAAOX,cAAc,0EACpC0D,eAAiB/C,OAAOX,cAAc,qFAyGnC2D,+BAA+BC,eAC7BC,UAAWC,YAAcF,WAEN,cAAtBE,WAAWC,mBAEXC,oBAAoBF,WAAWG,cAG7BC,aAAeJ,WAAWK,SAGhCD,aAAaE,iBAAiB,GAAGnD,iBAAiB,QAASoD,mBAGlC,cAArBR,UAAUE,2BAGNrC,MAAM,wDAA0DmC,UAAUI,aAC9EK,sBAAsBJ,oBAGpBK,YAAcV,UAAUM,MAIxBK,eAAiB,IAAIC,YAC3BP,aAAaQ,YAAYhE,SAAQ,SAASiE,OACnB,UAAfA,MAAMC,KACNJ,eAAeK,SAASF,OAExBA,MAAMG,UAGdP,YAAYQ,iBAAiBrE,SAAQ,SAASsE,UAC1CR,eAAeK,SAASG,aAG5BV,sBAAsBE,yBAQjBF,sBAAsBW,eAC3BzC,YAAcyC,OAGd/B,aAAagC,UAAYD,OACzB/B,aAAaiC,OAAQ,EACbjD,cAAciB,UACb,QACDiC,cACArC,OAAO5B,UAAW,EAClB4B,OAAOsC,kBAGN,QACDnC,aAAaoC,OACbpC,aAAaqC,UAAW,EAExB5E,OAAON,QAAQmF,MAAQ,WACvBC,eAAe,kBACf1C,OAAO5B,UAAW,EAClB4B,OAAOsC,QACP1E,OAAOX,cAAc,gCAAgCmB,UAAW,YAG/D,SACD+B,aAAaoC,OACbpC,aAAaqC,UAAW,EACxBH,cACAzE,OAAOX,cAAc,gCAAgCmB,UAAW,EAKpE6B,cACAA,YAAY7B,UAAW,YAQtBiE,cAEL3C,cAAgB,IAAIiD,cAAclD,6BAwmB5BmD,QAAU,MAGW,UAAvBzD,cAAciB,KACdwC,QAAQC,mBAAqB1D,cAAc2D,aACxC,GAAIC,mBAAoB,CAC3BH,QAAQI,mBAAqB7D,cAAc2D,QAC3CF,QAAQK,WAAa9D,cAAc+D,MACnCN,QAAQO,YAAchE,cAAciE,WAG/B,IAAIC,EAAI,EAAGA,EAAIlE,cAAcmE,UAAUC,OAAQF,OAC5CV,cAAca,gBAAgBrE,cAAcmE,UAAUD,IAAK,CAC3DT,QAAQa,SAAWtE,cAAcmE,UAAUD,iBAMhDT,QA3nBwCc,IAE/ChE,cAAciE,gBAAkBC,oBAChClE,cAAcmE,QAAUD,oBACxBlE,cAAcoE,OAASC,0BACvBrE,cAAcsE,MAAM,KAEpBpG,OAAON,QAAQmF,MAAQ,YAqCvBjD,qBAAuBe,YAAY0D,QAAQ,CACvC,CAACC,SAAU,mBACX,CAACA,SAAU,sBACZ,CACCC,SAAgD,IAAtCvG,OAAON,QAAQ8G,qBACzBC,KAAM,WACNC,MAAO,IAxCX9E,qBAAqB+C,OACrBG,eAAe,iBAsQf7C,cAAsD,IAAtCjC,OAAON,QAAQ8G,qBAC/BG,uBACAC,qBAtQIzB,qBACA/C,OAAOyE,cAAcpG,UAAUqG,IAAI,QACnCxE,WAAW7B,UAAUC,OAAO,QAC5B4B,WAAW7B,UAAUqG,IAAI,UACzBpE,YAAYjC,UAAUC,OAAO,kBAO5BgD,uBACwB,aAAzB1D,OAAON,QAAQmF,MACf7E,OAAON,QAAQmF,MAAQ,MACvBtC,aAAasE,cAAcpG,UAAUqG,IAAI,QACzCrE,mBAAmBhC,UAAUC,OAAO,QACpCoE,eAAe,oBACf1C,OAAO2E,WACJ,OACGC,UAAYhH,OAAOX,cAAc,gCAClC2H,UAAUvG,UAAUwG,SAAS,SAC9BD,UAAU3H,cAAc,gCAAgC6H,QAGhEC,4BAsBKnB,oBAAoBoB,OACpBA,MAAMC,OAKXrF,oBAAsBoF,MAAMC,KAAKC,KAC7B7F,WAAW8F,eAAiB,GAAKvF,oBAAsBP,WAAW8F,gBAG7DC,aAAaC,QAAQ,WAMtBD,aAAaE,WAAW,YALxBF,aAAaG,QAAQ,UAAW,QAChCC,gBACApG,MAAMqG,UAAU,oBAQxB9F,OAAO+F,KAAKV,MAAMC,WAIsB,IAA7BpG,EAAE8G,wBACRC,OAAOC,SAASC,SAASC,SAAS,+CACnClH,EAAE8G,uBAAuBK,6BAiCxBR,gBAELxF,OAAO5B,UAAW,EAGlB6H,qBAGAjG,OAAO3B,UAAUC,OAAO,cACxB0B,OAAO3B,UAAUqG,IAAI,sBACjBzE,cACAiG,oBAAoB,SACpBjG,YAAYwE,cAAcpG,UAAUqG,IAAI,SAI5ClF,qBAAqB2G,SAGrBzG,cAAcqC,aAGRqE,OAAS3G,YAAYkC,gBACtB,IAAI0B,EAAI,EAAGA,EAAI+C,OAAO7C,OAAQF,IAC/B+C,OAAO/C,GAAGtB,gBAOTgC,+BACwB,QAAzBnG,OAAON,QAAQmF,6BA8CS4D,oBACtBC,yPAwCczH,EAAE0H,IAAIC,QAAU,0UAAhB3H,EAAE0H,IAAIC,QAAU,0GAAhB3H,EAAE0H,IAAIC,QAAU,kDAxCjBC,UACZ,IAAIC,SAASC,cACX5D,+BAED4D,QAAQN,oBAGNO,OAAS,IAAIN,KAAKO,OAClBC,QAAU,IAAIR,KAAKS,QACnBC,MAAQV,KAAKU,MACbC,WAAa,IAAIC,WACvBD,WAAWE,OAAS,eAGKL,QAAQM,OAAO7H,KAAK8H,QAC5B1J,SAAQ,SAAS2J,SACtBV,OAAOW,KAAKD,YAEhBV,OAAO7E,aAEDyF,mBAAqBR,MAAMS,qBAAqBb,OAAOc,UAAWd,OAAOzC,SAAUyC,OAAOe,MAC1FC,KAAOrI,KAAK8H,OAAOQ,MAAMjB,OAAOkB,cAChCC,aAAe,IAAIC,KAAK,CAACR,mBAAoBI,MAAO,CAACK,KAAMvI,cAAc+D,WAC/EkD,QAAQoB,cACV,MAAOG,GAELvB,QAAQN,gBAIhBY,WAAWkB,kBAAkB9B,kBAtEjC+B,CAFa,IAAIJ,KAAKrI,OAAQ,CAACsI,KAAMvI,cAAc+D,YAE5BjG,MAAK6K,UAExBlI,aAAagC,UAAY,KACzBhC,aAAamI,IAAMC,IAAIC,gBAAgBH,SAGvClI,aAAaiC,OAAQ,EACrBjC,aAAaqC,UAAW,EACxBrC,aAAasE,cAAcpG,UAAUC,OAAO,QAC5C+B,mBAAmBhC,UAAUqG,IAAI,QACjCvE,aAAamC,QAEc,UAAvBnD,cAAciB,KACdE,YAAYjC,UAAUqG,IAAI,SAG1B1E,OAAOyE,cAAcpG,UAAUC,OAAO,QACtC4B,WAAW7B,UAAUqG,IAAI,QACzBxE,WAAW7B,UAAUC,OAAO,WAIhC0B,OAAO5B,UAAW,EAClB4B,OAAO3B,UAAUC,OAAO,cACxB0B,OAAO3B,UAAUqG,IAAI,sBACrB9G,OAAON,QAAQmF,MAAQ,WAEnB9C,OAAO4D,OAAS,GAChBnE,MAAMqJ,wBAAwBnJ,sBA4DjC2B,oBAAoBvC,oBACrBC,MAAM,4DACNA,MAAMD,OAEVgK,sBAAsB,mBACtBhG,eAAe,gBACf1C,OAAO3B,UAAUC,OAAO,cACxB0B,OAAO3B,UAAUqG,IAAI,sBACrB9G,OAAON,QAAQmF,MAAQ,MAEvBnC,YAAYjC,UAAUqG,IAAI,QAEtBhF,eAAyC,aAAxBA,cAAc+C,OAC/B/C,cAAcqC,aAIZ4G,WAAa,MAAQjK,MAAM0B,KAAKwI,QAAQ,QAAS,IAAIC,cAE3DzJ,MAAMqG,UAAUkD,YAChB5D,4BAeKkB,qBACLpG,cAAgBC,SAAWgJ,KAAKC,MACR,IAApBhJ,kBACAiJ,cAAcjJ,iBACdA,gBAAkB,YAOjBwE,uBACLzE,SAAWgJ,KAAKC,MAAQlJ,cACA,IAApBE,kBACAA,gBAAkBkJ,YAAYzE,mBAAoB,eAOjDA,2BACC0E,sBAAwBpJ,SAAWgJ,KAAKC,MACxCI,iBAAmBC,KAAKC,MAAMH,sBAAwB,KAG5DI,iBAFqB1L,OAAON,QAAQ8G,qBAAuB+E,iBAE5BA,kBAC3BD,uBAAyB,GACzB1D,yBAUC+D,qBAAqBC,eACpBC,KAAOD,QAAU,GACjBE,KAAON,KAAKC,OAAOG,QAAUC,MAAQ,WAEpC5K,EAAEC,KAAK6K,WAAW,cAAe,kBACpC,CAACD,KAAME,IAAIF,MAAOD,KAAMG,IAAIH,iBAa3BH,iBAAiBO,aAAcV,kBAEpC3I,YAAYsJ,UAAYP,qBAAqBJ,kBAC7C1I,cAAcqJ,UAAYP,qBAAqBM,cAE/CnJ,aAAaoJ,UAAYP,qBAAqBJ,kBAC9CxI,eAAemJ,UAAYP,qBAAqBM,uBAS3CD,IAAIG,WACHC,UAAYD,IAAM,UAEpBC,UAAUzG,OAAS,EACZ,IAAMyG,UAEN,GAAKA,mBAmDXC,aAAaC,UAAWC,qBACtB,IAAIzD,SAASC,gBACVyD,aAAe,IAAIC,eACzBD,aAAaE,KAAK,MAAOJ,WACzBE,aAAaD,aAAeA,aAC5BC,aAAalM,iBAAiB,QAAQ,KAClCyI,QAAQyD,aAAaG,aAEzBH,aAAaI,yBA4ENC,oBAAoBC,QAASC,OACxCjI,eAAe,yBAA0B0G,KAAKC,MAAM,IAAMqB,QAAUC,cAE9D,IAAIjE,SAAQC,SAAWiE,sBAAsBjE,oBAS9CkE,uBAAuBC,KAAMC,yBAG5BC,SAAW,IAAIC,SACrBD,SAASE,OAAO,mBAAoBJ,KAAMC,mBAC1CC,SAASE,OAAO,UAAWrM,EAAE0H,IAAI4E,SACjCH,SAASE,OAAO,UAAW7L,WAAW+L,oBACtCJ,SAASE,OAAO,SAAU7L,WAAWgM,aACrCL,SAASE,OAAO,WAAY,KAC5BF,SAASE,OAAO,SAAU7L,WAAWiM,WACrCN,SAASE,OAAO,YAAa,WAEvBK,cAAgB,IAAIlB,eAC1BkB,cAAcrN,iBAAiB,mBAAoBsN,+BACnDD,cAAcE,OAAOvN,iBAAiB,WAAYwN,sBAClDH,cAAcrN,iBAAiB,QAASyN,mBACxCJ,cAAcrN,iBAAiB,QAAS0N,mBACxCL,cAAcjB,KAAK,OAAQzL,EAAE0H,IAAIC,QAAU,iDAC3C+E,cAAcf,KAAKQ,mBAOdQ,8BAA8BtD,SAC7BqD,cAAgBrD,EAAE2D,UACS,IAA7BN,cAAcO,kBAIDC,KAAKC,MAAMT,cAAcU,cAC7BC,WACTP,oBAGyB,MAAzBJ,cAAcvK,QAEd0B,eAAe,gBACf1C,OAAO3B,UAAUC,OAAO,sBACxByG,oBACgC,MAAzBwG,cAAcvK,SACrB0H,sBAAsB,mBACtB3D,6BAQC2G,qBAAqBxD,GAC1BxF,eAAe,iBAAkB0G,KAAKC,MAAMnB,EAAEiE,OAASjE,EAAEyC,MAAQ,KAAO,cAMnEgB,oBACLjD,sBAAsB,gBACtB3D,4BAMK6G,oBACLlD,sBAAsB,iBACtB3D,4BASKrC,eAAe0J,WAAYC,QACtBC,IAAND,IAEAA,EAAI,+BAAiCzO,OAAON,QAAQiP,WAAa,WAErEvM,OAAOwM,UAAY3N,EAAEC,KAAK6K,WAAWyC,WAAY,kBAAmBC,YAQ/DnG,oBAAoBkG,YACzBnM,YAAY6J,UAAYjL,EAAEC,KAAK6K,WAAWyC,WAAY,4BAQjD1D,sBAAsB0D,YAC3B/L,mBAAmBoM,YAAc5N,EAAEC,KAAK6K,WAAWyC,WAAY,mBAC/DjM,aAAasE,cAAcpG,UAAUqG,IAAI,QACzCrE,mBAAmBhC,UAAUC,OAAO,iBAkC/ByG,mBACL2H,wBAAuB,GACvBtN,MAAMuN,qCAeDD,6BAAuBE,gEAC5BpQ,SAASG,iBAAiB,kBAAkBgB,SAAQkP,SAChDA,OAAOlQ,iBAAiB,kDAAkDgB,SAAQqC,SAC9EA,OAAO5B,UAAYwO,uBAQtBE,yBAEkB,aADAtN,qBAAqBuN,WAAa,WAErDvN,qBAAqBwN,QAErBxN,qBAAqB+C,gBAOpBQ,yBACyB,UAAvB5D,cAAciB,MAA2C,WAAvBjB,cAAciB,KA12B3DxC,OAAOM,iBAAiB,kBAQGgK,SACjB+E,cAAgB/E,EAAE2D,OAAOqB,QAAQ,cAClCD,eAAiBA,cAAc5O,UAAUwG,SAAS,uBAGvDqD,EAAEiF,iBACMvP,OAAON,QAAQmF,WACd,UACA,6BA6BHlF,aAAeK,OAAOX,cAAc,sBACtCM,cACAA,aAAae,eAGXT,aAAeD,OAAOX,cAAc,SACtCY,cAAgBA,aAAaQ,UAAUwG,SAAS,WAChDhH,aAAaQ,UAAUC,OAAO,UAIlCgL,iBAAiB,EAAG8D,SAASxP,OAAON,QAAQ8G,uBAEjB,UAAvBjF,cAAciB,MACdD,aAAasE,cAAcpG,UAAUqG,IAAI,QACzCrE,mBAAmBhC,UAAUqG,IAAI,QACjCpE,YAAYjC,UAAUC,OAAO,UAG7B6B,aAAasE,cAAcpG,UAAUC,OAAO,QAC5C+B,mBAAmBhC,UAAUqG,IAAI,YAErCzE,MAAAA,aAAAA,YAAawE,cAAcpG,UAAUC,OAAO,QAG5C0B,OAAO3B,UAAUC,OAAO,sBACxB0B,OAAO3B,UAAUqG,IAAI,yBAmwBrBgI,wBAAuB,GAhwBvBW,GAGA1N,OAAS,GACTC,mBAAqB,EAGM,WAAvBT,cAAciB,iBACdkN,UAAUC,aAAaC,aAAarO,cAAcsO,kBAC7CjQ,KAAK+D,uBACL9C,MAAMwC,2BAKTyM,aAAeJ,UAAUC,aAAaC,aAAa,CAACG,OAAO,IAC3DC,cAAgBN,UAAUC,aAAaM,gBAAgB1O,cAAcsO,kBAK3E/G,QAAQoH,WAAW,CAACJ,aAAcE,gBAAgBpQ,KAAKoD,gCA9E/CmN,aAEC,WACD1L,wBAEC,YACG4K,gBAAkBhN,aAwQ9BgG,qBACAC,oBAAoB,UACpBxG,cAAcsN,QACdpP,OAAON,QAAQmF,MAAQ,SAEvBqK,0BA1QYtH,0BAGH,SACGyH,gBAAkBhN,aA8Q9BsE,uBACA3G,OAAON,QAAQmF,MAAQ,YACvByD,oBAAoB,SACpBxG,cAAcsO,SAEdlB,0BAhRYtH,yBAhCXyI,wCA6iBDvL,eAAe,mBAEX9E,OAAON,QAAQ4Q,aAAc,OACvBC,iCAgBiBjE,iBACrBkE,2PAacvP,EAAE0H,IAAIC,QAAU,8VAAhB3H,EAAE0H,IAAIC,QAAU,8HAAhB3H,EAAE0H,IAAIC,QAAU,sEAbf6H,GACfC,cAAgBrE,aAAaC,UAAW,eACxCqE,kBAAqB,IAAIC,cAAgBC,gBAAgBH,UACxDI,KAAMC,gBAsCkBC,eACzBC,YAAc,OAEf,IAAIC,QAAU,EAAGA,QAAUF,QAAQG,iBAAkBD,UAAW,OAC3DE,eAAiBJ,QAAQK,eAAeH,SAC9CD,YAAYC,SAAW,IAAII,WAAWN,QAAQrL,YACzC,IAAIF,EAAI,EAAGA,EAAIuL,QAAQrL,OAAQF,IAGhCwL,YAAYC,SAASzL,GAAyB,MAApB2L,eAAe3L,UAI1CwL,YAnDeM,CAA0BZ,yCAgE3BH,OAAQgB,SAAUC,WAAYX,UAAMC,6DAAQ,WAC3DW,OAAS,GACTC,OAAS,IAAInB,OAAOoB,WAAWJ,SAAUC,WAAYlQ,cAAc2D,QAAU,SAC/E2M,UAAYf,KAAKnL,aACfmM,gBAAkB,SACpBC,aAEElF,oBAAoB,EAAGiE,KAAKnL,YAC7B,IAAIF,EAAI,EAAGoM,WAAaC,gBAAiBrM,GAAKqM,gBAAiB,IAC/C,IAAbN,SAAgB,OACVQ,KAAOlB,KAAKmB,SAASxM,EAAGA,EAAIqM,iBAClCC,OAASJ,OAAOO,aAAaF,UAC1B,OACGG,UAAYrB,KAAKmB,SAASxM,EAAGA,EAAIqM,iBACjCM,WAAarB,MAAMkB,SAASxM,EAAGA,EAAIqM,iBACzCC,OAASJ,OAAOO,aAAaC,UAAWC,YAExCL,OAAOpM,OAAS,GAChB+L,OAAO5J,KAAKiK,QAEhBF,WAAaC,gBACTrM,GAAK,GAAKqM,kBAAqB,SACzBjF,oBAAoBpH,EAAGqL,KAAKnL,cAGpC0M,EAAIV,OAAOW,QACbD,EAAE1M,OAAS,GACX+L,OAAO5J,KAAK,IAAIyK,UAAUF,iBAExBxF,oBAAoBiE,KAAKnL,OAAQmL,KAAKnL,QAErC,IAAIyE,KAAKsH,OAAQ,CAACrH,KAAM,cA9FlBmI,CAAUhC,OAAQG,YAAYQ,iBAAkBR,YAAYc,WAAYX,KAAMC,OArB7D0B,CAAgBlQ,aAAamI,KACvDnI,aAAamI,IAAMC,IAAIC,gBAAgB2F,aACvCtD,uBAAuBsD,YAAavQ,OAAON,QAAQyN,kBAAkBnC,QAAQ,SAAU,aACpF,CAGHiC,6BAD0BZ,aAAa9J,aAAamI,IAAK,QACrB1K,OAAON,QAAQyN,8BA6TtDuF,cAAcxN,cACd1C,KAAO,aACP0C,QAAUsK,SAAStK,QAAS,SAC5B2K,iBAAmB,CACpBE,OAAO,QAENrK,UAAY,CACb,yBACA,kCAYCiN,cAAczN,QAASI,MAAOE,aAC9BhD,KAAO,aACP0C,QAAUsK,SAAStK,QAAS,SAC5BI,MAAQkK,SAASlK,MAAO,SACxBE,OAASgK,SAAShK,OAAQ,SAC1BqK,iBAAmB,CACpBE,OAAO,EACP6C,MAAO,CACHtN,MAAO,CAACuN,MAAOlR,KAAK2D,OACpBE,OAAQ,CAACqN,MAAOlR,KAAK6D,eAGxBE,UAAY,CACb,6BACA,8BACA,uCAYCoN,eAAe5N,QAASI,MAAOE,aAC/BhD,KAAO,cACP0C,QAAUsK,SAAStK,QAAS,SAC5BI,MAAQkK,SAASlK,MAAO,SACxBE,OAASgK,SAAShK,OAAQ,SAC1BqK,iBAAmB,CACpBE,OAAO,EACPgD,YAAa,UACbH,MAAO,CACHI,eAAgB,UAChBC,UAAW,CAACJ,MAAO,IAGnBvN,MAAO,CAAC4N,IAAKvR,KAAK2D,OAClBE,OAAQ,CAAC0N,IAAKvR,KAAK6D,eAKtBE,UAAY,CACb,6BACA,6BACA,wCAWCtE,kBAAkB1C,WAAYsC,gBAC7BrC,YAAcC,SAASC,eAAeH,YAGtC+K,OAtiCAiG,UAAUC,cAAgB3H,OAAOjD,cAKb,WAAtBkD,SAASkL,UACa,cAAlBlL,SAASmL,MAA0C,cAAlBnL,SAASmL,KACvC,KAEA,WARA,cAsiCI,aAAX3J,mBACA9K,YAAYU,cAAc,kBAAkBoB,UAAUC,OAAO,QAE1D,GAAe,aAAX+I,mBACP9K,YAAYU,cAAc,sBAAsBoB,UAAUC,OAAO,aAKhEmH,mBA0DcwL,gBACRC,uBAAaC,OAAO,CACvBlJ,KAAMiJ,uBAAaE,MAAMC,MACzBC,MAAOzS,EAAEC,KAAK6K,WAAWsH,QAAU,SAAU,mBAC7CrJ,KAAM/I,EAAEC,KAAK6K,WAAWsH,QAAS,qBAClCzT,MAAK,SAAS+T,cACbA,MAAMC,OACCD,eAhEV9I,iCAyE4BnJ,UAC7BA,SAAS2O,4BAzERtB,0BAA4B8E,2BAC3BC,aAAenS,cA+BZkS,2BACDE,aAAc,EAClBpV,YAAYI,iBAAiB,gGACxBgB,SAAQ,SAASC,QACe,aAAzBA,OAAON,QAAQmF,QACfkP,aAAc,YAOpBC,aAAerV,YAAYU,cAAc,qCAC3C2U,eACAA,aAAaxT,UAAYuT,aA1CjCpV,YAAYI,iBAAiB,gGACxBgB,SAAQ,SAASC,YAEViU,gBACIjU,OAAON,QAAQwU,eACd,QACDD,SAAW,IAAIvB,cAAc1R,SAASmT,wBAErC,SACDF,SAAW,IAAInB,eAAe9R,SAASoT,cAAepT,SAASqT,YAAarT,SAASsT,4BAGrFL,SAAW,IAAItB,cAAc3R,SAASuT,aAAcvT,SAASqE,WAAYrE,SAASuE,wBAKtFjE,SAAStB,OAAQiU,SAAUH,aAAc9S,UACtC,cAEf6S"}