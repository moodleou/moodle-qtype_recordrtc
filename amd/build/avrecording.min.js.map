{"version":3,"file":"avrecording.min.js","sources":["../src/avrecording.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n//\n\n/**\n * JavaScript to the recording work.\n *\n * We would like to thank the creators of atto_recordrtc, whose\n * work originally inspired this.\n *\n * This script uses some third-party JavaScript and loading that within Moodle/ES6\n * requires some contortions. The main classes here are:\n *\n * * Recorder - represents one recording widget. This works in a way that is\n *   not particularly specific to this question type.\n * * RecordRtcQuestion - represents one question, which may contain several recorders.\n *   It deals with the interaction between the recorders and the question.\n *\n * @module    qtype_recordrtc/avrecording\n * @copyright 2019 The Open University\n * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Log from 'core/log';\nimport ModalFactory from 'core/modal_factory';\n\n/**\n * Verify that the question type can work. If not, show a warning.\n *\n * @return {string} 'ok' if it looks OK, else 'nowebrtc' or 'nothttps' if there is a problem.\n */\nfunction checkCanWork() {\n    if (!(navigator.mediaDevices && window.MediaRecorder)) {\n        return 'nowebrtc';\n    }\n\n    if (!(location.protocol === 'https:' || location.host.indexOf('localhost') !== -1)) {\n        return 'nothttps';\n    }\n\n    return 'ok';\n}\n\n/**\n * Object for actually doing the recording.\n *\n * The recorder can be in one of several states, which is stored in a data-state\n * attribute on the outer span (widget). The states are:\n *\n *  - new:       there is no recording yet. Button shows 'Start recording' (audio) or 'Start camera' (video).\n *  - starting:  (video only) camera has started, but we are not recording yet. Button show 'Start recording'.\n *  - recording: Media is being recorded. Pause button visible if allowed. Main button shows 'Stop'. Countdown displayed.\n *  - paused:    If pause was pressed. Media recording paused, but resumable. Pause button changed to say 'resume'.\n *  - saving:    Media being uploaded. Progress indication shown. Pause button hidden if was visible.\n *  - recorded:  Recording and upload complete. Buttons shows 'Record again'.\n *\n * @param {HTMLElement} widget the DOM node that is the top level of the whole recorder.\n * @param {(AudioSettings|VideoSettings)} mediaSettings information about the media type.\n * @param {Object} owner the object we are doing the recording for. Must provide three callback functions\n *                       showAlert notifyRecordingComplete notifyButtonStatesChanged.\n * @param {Object} uploadInfo object with fields uploadRepositoryId, draftItemId, contextId and maxUploadSize.\n * @constructor\n */\nfunction Recorder(widget, mediaSettings, owner, uploadInfo) {\n    /**\n     * @type {Recorder} reference to this recorder, for use in event handlers.\n     */\n    const recorder = this;\n\n    /**\n     * @type {MediaStream} during recording, the stream of incoming media.\n     */\n    let mediaStream = null;\n\n    /**\n     * @type {MediaRecorder} the recorder that is capturing stream.\n     */\n    let mediaRecorder = null;\n\n    /**\n     * @type {Blob[]} the chunks of data that have been captured so far during the current recording.\n     */\n    let chunks = [];\n\n    /**\n     * @type {number} number of bytes recorded so far, so we can auto-stop\n     * before hitting Moodle's file-size limit.\n     */\n    let bytesRecordedSoFar = 0;\n\n    /**\n     * @type {number} when paused, the time left in milliseconds, so we can auto-stop at the time limit.\n     */\n    let timeRemaining = 0;\n\n    /**\n     * @type {number} while recording, the time we reach the time-limit, so we can auto-stop then.\n     * This is milliseconds since Unix epoch, so comparable with Date.now().\n     */\n    let stopTime = 0;\n\n    /**\n     * @type {number} intervalID returned by setInterval() while the timer is running.\n     */\n    let countdownTicker = 0;\n\n    const button = widget.querySelector('button.qtype_recordrtc-main-button');\n    const pauseButton = widget.querySelector('.qtype_recordrtc-pause-button button');\n    const controlRow = widget.querySelector('.qtype_recordrtc-control-row');\n    const mediaElement = widget.querySelector('.qtype_recordrtc-media-player ' + mediaSettings.name);\n    const noMediaPlaceholder = widget.querySelector('.qtype_recordrtc-no-recording-placeholder');\n    const timeDisplay = widget.querySelector('.qtype_recordrtc-time-left');\n\n    widget.addEventListener('click', handleButtonClick);\n    this.uploadMediaToServer = uploadMediaToServer; // Make this method available.\n\n    /**\n     * Handles clicks on the start/stop and pause buttons.\n     *\n     * @param {Event} e\n     */\n    function handleButtonClick(e) {\n        const clickedButton = e.target.closest('button');\n        if (!clickedButton) {\n            return; // Not actually a button click.\n        }\n        e.preventDefault();\n        switch (widget.dataset.state) {\n            case 'new':\n            case 'recorded':\n                startRecording();\n                break;\n            case 'starting':\n                startSaving();\n                break;\n            case 'recording':\n                if (clickedButton === pauseButton) {\n                    pause();\n                } else {\n                    stopRecording();\n                }\n                break;\n            case 'paused':\n                if (clickedButton === pauseButton) {\n                    resume();\n                } else {\n                    stopRecording();\n                }\n                break;\n        }\n    }\n\n    /**\n     * Start recording (because the button was clicked).\n     */\n    function startRecording() {\n\n        if (mediaSettings.name === 'audio') {\n            mediaElement.parentElement.classList.add('hide');\n            noMediaPlaceholder.classList.add('hide');\n            timeDisplay.classList.remove('hide');\n\n        } else {\n            mediaElement.parentElement.classList.remove('hide');\n            noMediaPlaceholder.classList.add('hide');\n        }\n        pauseButton?.parentElement.classList.remove('hide');\n\n        // Change look of recording button.\n        button.classList.remove('btn-outline-danger');\n        button.classList.add('btn-danger');\n\n        // Disable other question buttons when current widget stared recording.\n        disableAllButtons();\n\n        // Empty the array containing the previously recorded chunks.\n        chunks = [];\n        bytesRecordedSoFar = 0;\n        navigator.mediaDevices.getUserMedia(mediaSettings.mediaConstraints)\n            .then(handleCaptureStarting)\n            .catch(handleCaptureFailed);\n    }\n\n    /**\n     * Callback once getUserMedia has permission from the user to access the recording devices.\n     *\n     * @param {MediaStream} stream the stream to record.\n     */\n    function handleCaptureStarting(stream) {\n        mediaStream = stream;\n\n        // Setup the UI for during recording.\n        mediaElement.srcObject = stream;\n        mediaElement.muted = true;\n        if (mediaSettings.name === 'audio') {\n            startSaving();\n        } else {\n            mediaElement.play();\n            mediaElement.controls = false;\n\n            widget.dataset.state = 'starting';\n            setButtonLabel('startrecording');\n            widget.querySelector('.qtype_recordrtc-stop-button').disabled = false;\n        }\n\n        // Make button clickable again, to allow starting/stopping recording.\n        if (pauseButton) {\n            pauseButton.disabled = false;\n        }\n        button.disabled = false;\n        button.focus();\n    }\n\n    /**\n     * For recording types which show the media during recording,\n     * this starts the loop-back display, but does not start recording it yet.\n     */\n    function startSaving() {\n        // Initialize MediaRecorder events and start recording.\n        mediaRecorder = new MediaRecorder(mediaStream, getRecordingOptions());\n\n        mediaRecorder.ondataavailable = handleDataAvailable;\n        mediaRecorder.onpause = handleDataAvailable;\n        mediaRecorder.onstop = handleRecordingHasStopped;\n        mediaRecorder.start(1000); // Capture in one-second chunks. Firefox requires that.\n\n        widget.dataset.state = 'recording';\n        setButtonLabel('stoprecording');\n        startCountdownTimer();\n        if (mediaSettings.name === 'video') {\n            button.parentElement.classList.add('hide');\n            controlRow.classList.remove('hide');\n            controlRow.classList.add('d-flex');\n        }\n    }\n\n    /**\n     * Callback that is called by the media system for each Chunk of data.\n     *\n     * @param {BlobEvent} event\n     */\n    function handleDataAvailable(event) {\n        if (!event.data) {\n            return; // It seems this can happen around pausing.\n        }\n\n        // Check there is space to store the next chunk, and if not stop.\n        bytesRecordedSoFar += event.data.size;\n        if (uploadInfo.maxUploadSize >= 0 && bytesRecordedSoFar >= uploadInfo.maxUploadSize) {\n\n            // Extra check to avoid alerting twice.\n            if (!localStorage.getItem('alerted')) {\n                localStorage.setItem('alerted', 'true');\n                stopRecording();\n                owner.showAlert('nearingmaxsize');\n\n            } else {\n                localStorage.removeItem('alerted');\n            }\n        }\n\n        // Store the next chunk of data.\n        chunks.push(event.data);\n\n        // Notify form-change-checker that there is now unsaved data.\n        // But, don't do this in question preview where it is just annoying.\n        if (typeof M.core_formchangechecker !== 'undefined' &&\n            !window.location.pathname.endsWith('/question/preview.php')) {\n            M.core_formchangechecker.set_form_changed();\n        }\n    }\n\n    /**\n     * Pause recording.\n     */\n    function pause() {\n        // Stop the count-down timer.\n        stopCountdownTimer();\n        setPauseButtonLabel('resume');\n        mediaRecorder.pause();\n        widget.dataset.state = 'paused';\n    }\n\n    /**\n     * Continue recording.\n     */\n    function resume() {\n        // Stop the count-down timer.\n        resumeCountdownTimer();\n        widget.dataset.state = 'recording';\n        setPauseButtonLabel('pause');\n        mediaRecorder.resume();\n    }\n\n    /**\n     * Start recording (because the button was clicked or because we have reached a limit).\n     */\n    function stopRecording() {\n        // Disable the button while things change.\n        button.disabled = true;\n\n        // Stop the count-down timer.\n        stopCountdownTimer();\n\n        // Update the button.\n        if (widget.dataset.denyRerecord){\n            button.remove();\n            if (pauseButton){\n                pauseButton.parentElement.remove();\n            }\n        } else {\n            button.classList.remove('btn-danger');\n            button.classList.add('btn-outline-danger');\n            if (pauseButton) {\n                setPauseButtonLabel('pause');\n                pauseButton.parentElement.classList.add('hide');\n            }\n        }\n\n        // Ask the recording to stop.\n        mediaRecorder.stop();\n\n        // Also stop each individual MediaTrack.\n        const tracks = mediaStream.getTracks();\n        for (let i = 0; i < tracks.length; i++) {\n            tracks[i].stop();\n        }\n    }\n\n    /**\n     * Callback that is called by the media system once recording has finished.\n     */\n    function handleRecordingHasStopped() {\n        if (widget.dataset.state === 'new') {\n            // This can happens if an error occurs when recording is starting. Do nothing.\n            return;\n        }\n\n        // Set source of the media player.\n        const blob = new Blob(chunks, {type: mediaRecorder.mimeType});\n        mediaElement.srcObject = null;\n        mediaElement.src = URL.createObjectURL(blob);\n\n        // Show audio player with controls enabled, and unmute.\n        mediaElement.muted = false;\n        mediaElement.controls = true;\n        mediaElement.parentElement.classList.remove('hide');\n        noMediaPlaceholder.classList.add('hide');\n        mediaElement.focus();\n\n        if (mediaSettings.name === 'audio') {\n            timeDisplay.classList.add('hide');\n        } else {\n            button.parentElement?.classList.remove('hide');\n            controlRow.classList.add('hide');\n            controlRow.classList.remove('d-flex');\n        }\n\n        // Ensure the button while things change.\n        if (button.parentElement){\n            button.disabled = true;\n            button.classList.remove('btn-danger');\n            button.classList.add('btn-outline-danger');\n        }\n\n        widget.dataset.state = 'recorded';\n\n        if (chunks.length > 0) {\n            owner.notifyRecordingComplete(recorder);\n        }\n    }\n\n    /**\n     * Function that handles errors from the recorder.\n     *\n     * @param {DOMException} error\n     */\n    function handleCaptureFailed(error) {\n        Log.debug('Audio/video question: error received');\n        Log.debug(error);\n\n        setPlaceholderMessage('recordingfailed');\n        setButtonLabel('recordagainx');\n        button.classList.remove('btn-danger');\n        button.classList.add('btn-outline-danger');\n        widget.dataset.state = 'new';\n\n        if (mediaRecorder) {\n            mediaRecorder.stop();\n        }\n\n        // Changes 'CertainError' -> 'gumcertain' to match language string names.\n        const stringName = 'gum' + error.name.replace('Error', '').toLowerCase();\n\n        owner.showAlert(stringName);\n        enableAllButtons();\n    }\n\n    /**\n     * Start the countdown timer.\n     */\n    function startCountdownTimer() {\n        timeRemaining = widget.dataset.maxRecordingDuration * 1000;\n        resumeCountdownTimer();\n        updateTimerDisplay();\n    }\n\n    /**\n     * Stop the countdown timer.\n     */\n    function stopCountdownTimer() {\n        timeRemaining = stopTime - Date.now();\n        if (countdownTicker !== 0) {\n            clearInterval(countdownTicker);\n            countdownTicker = 0;\n        }\n    }\n\n    /**\n     * Start or resume the countdown timer.\n     */\n    function resumeCountdownTimer() {\n        stopTime = Date.now() + timeRemaining;\n        if (countdownTicker === 0) {\n            countdownTicker = setInterval(updateTimerDisplay, 100);\n        }\n    }\n\n    /**\n     * Update the countdown timer, and stop recording if we have reached 0.\n     */\n    function updateTimerDisplay() {\n        const millisecondsRemaining = stopTime - Date.now();\n        const secondsRemaining = Math.round(millisecondsRemaining / 1000);\n        const secs = secondsRemaining % 60;\n        const mins = Math.round((secondsRemaining - secs) / 60);\n\n        timeDisplay.innerText = M.util.get_string('timedisplay', 'qtype_recordrtc',\n                {mins: pad(mins), secs: pad(secs)});\n\n        if (millisecondsRemaining <= 0) {\n            stopRecording();\n        }\n    }\n\n    /**\n     * Zero-pad a string to be at least two characters long.\n     *\n     * @param {number} val e.g. 1 or 10\n     * @return {string} e.g. '01' or '10'.\n     */\n    function pad(val) {\n        const valString = val + '';\n\n        if (valString.length < 2) {\n            return '0' + valString;\n        } else {\n            return '' + valString;\n        }\n    }\n\n    /**\n     * Trigger the upload of the recorded media back to Moodle.\n     */\n    function uploadMediaToServer() {\n        setButtonLabel('uploadpreparing');\n\n        // First we need to get the media data from the media element.\n        const fetchRequest = new XMLHttpRequest();\n        fetchRequest.open('GET', mediaElement.src);\n        fetchRequest.responseType = 'blob';\n        fetchRequest.addEventListener('load', handleRecordingFetched);\n        fetchRequest.send();\n    }\n\n    /**\n     * Callback called once we have the data from the media element, ready to upload to Moodle.\n     *\n     * @param {ProgressEvent} e\n     */\n    function handleRecordingFetched(e) {\n        const fetchRequest = e.target;\n        if (fetchRequest.status !== 200) {\n            // No data.\n            return;\n        }\n\n        // Blob is now the media that the audio/video tag's src pointed to.\n        const blob = fetchRequest.response;\n\n        // Create FormData to send to PHP filepicker-upload script.\n        const formData = new FormData();\n        formData.append('repo_upload_file', blob, widget.dataset.recordingFilename);\n        formData.append('sesskey', M.cfg.sesskey);\n        formData.append('repo_id', uploadInfo.uploadRepositoryId);\n        formData.append('itemid', uploadInfo.draftItemId);\n        formData.append('savepath', '/');\n        formData.append('ctx_id', uploadInfo.contextId);\n        formData.append('overwrite', '1');\n\n        const uploadRequest = new XMLHttpRequest();\n        uploadRequest.addEventListener('readystatechange', handleUploadReadyStateChanged);\n        uploadRequest.upload.addEventListener('progress', handleUploadProgress);\n        uploadRequest.addEventListener('error', handleUploadError);\n        uploadRequest.addEventListener('abort', handleUploadAbort);\n        uploadRequest.open('POST', M.cfg.wwwroot + '/repository/repository_ajax.php?action=upload');\n        uploadRequest.send(formData);\n    }\n\n    /**\n     * Callback for when the upload completes.\n     * @param {ProgressEvent} e\n     */\n    function handleUploadReadyStateChanged(e) {\n        const uploadRequest = e.target;\n        if (uploadRequest.readyState !== 4) {\n            return; // Not finished yet. We will get more of these events when it is.\n        }\n\n        const response = JSON.parse(uploadRequest.responseText);\n        if (response.errorcode) {\n            handleUploadError(); // Moodle sends back errors with a 200 status code for some reason!\n        }\n\n        if (uploadRequest.status === 200) {\n            // When request finished and successful.\n            setButtonLabel('recordagainx');\n            enableAllButtons();\n        } else if (uploadRequest.status === 404) {\n            setPlaceholderMessage('uploadfailed404');\n            enableAllButtons();\n        }\n    }\n\n    /**\n     * Callback for updating the upload progress.\n     * @param {ProgressEvent} e\n     */\n    function handleUploadProgress(e) {\n        setButtonLabel('uploadprogress', Math.round(e.loaded / e.total * 100) + '%');\n    }\n\n    /**\n     * Callback for when the upload fails with an error.\n     */\n    function handleUploadError() {\n        setPlaceholderMessage('uploadfailed');\n        enableAllButtons();\n    }\n\n    /**\n     * Callback for when the upload fails with an error.\n     */\n    function handleUploadAbort() {\n        setPlaceholderMessage('uploadaborted');\n        enableAllButtons();\n    }\n\n    /**\n     * Display a progress message in the upload progress area.\n     *\n     * @param {string} langString\n     * @param {string|null} [a] optional variable to populate placeholder with\n     */\n    function setButtonLabel(langString, a) {\n        if (!a) {\n            // Seemingly unnecessary space inside the span is needed for screen-readers, and it must be a non-breaking space.\n            a = '<span class=\"sr-only\">&nbsp;' + widget.dataset.widgetName + '</span>';\n        }\n        button.innerHTML = M.util.get_string(langString, 'qtype_recordrtc', a);\n    }\n\n    /**\n     * Display a progress message in the upload progress area.\n     *\n     * @param {string} langString\n     */\n    function setPauseButtonLabel(langString) {\n        pauseButton.innerText = M.util.get_string(langString, 'qtype_recordrtc');\n    }\n\n    /**\n     * Display a message in the upload progress area.\n     *\n     * @param {string} langString\n     */\n    function setPlaceholderMessage(langString) {\n        noMediaPlaceholder.textContent = M.util.get_string(langString, 'qtype_recordrtc');\n        mediaElement.parentElement.classList.add('hide');\n        noMediaPlaceholder.classList.remove('hide');\n    }\n\n    /**\n     * Select best options for the recording codec.\n     *\n     * @returns {Object}\n     */\n    function getRecordingOptions() {\n        const options = {};\n\n        // Get the relevant bit rates from settings.\n        if (mediaSettings.name === 'audio') {\n            options.audioBitsPerSecond = mediaSettings.bitRate;\n        } else if (mediaSettings.name === 'video') {\n            options.videoBitsPerSecond = mediaSettings.bitRate;\n            options.videoWidth = mediaSettings.width;\n            options.videoHeight = mediaSettings.height;\n\n            // Go through our list of mimeTypes, and take the first one that will work.\n            for (let i = 0; i < mediaSettings.mimeTypes.length; i++) {\n                if (MediaRecorder.isTypeSupported(mediaSettings.mimeTypes[i])) {\n                    options.mimeType = mediaSettings.mimeTypes[i];\n                    break;\n                }\n            }\n        }\n\n        return options;\n    }\n\n    /**\n     * Enable all buttons in the question.\n     */\n    function enableAllButtons() {\n        disableOrEnableButtons(true);\n        owner.notifyButtonStatesChanged();\n    }\n\n    /**\n     * Disable all buttons in the question.\n     */\n    function disableAllButtons() {\n        disableOrEnableButtons(false);\n    }\n\n    /**\n     * Disables/enables other question buttons when current widget started recording/finished recording.\n     *\n     * @param {boolean} enabled true if the button should be enabled.\n     */\n    function disableOrEnableButtons(enabled = false) {\n        widget.closest('.que').querySelectorAll('button, input[type=submit], input[type=button]').forEach(\n            function(button) {\n                button.disabled = !enabled;\n            }\n        );\n    }\n}\n\n/**\n * Object that controls the settings for recording audio.\n *\n * @param {string} bitRate desired audio bitrate.\n * @constructor\n */\nfunction AudioSettings(bitRate) {\n    this.name = 'audio';\n    this.bitRate = parseInt(bitRate, 10);\n    this.mediaConstraints = {\n        audio: true\n    };\n    this.mimeTypes = [\n        'audio/webm;codecs=opus',\n        'audio/ogg;codecs=opus'\n    ];\n}\n\n/**\n * Object that controls the settings for recording video.\n *\n * @param {string} bitRate desired video bitrate.\n * @param {string} width desired width.\n * @param {string} height desired height.\n * @constructor\n */\nfunction VideoSettings(bitRate, width, height) {\n    this.name = 'video';\n    this.bitRate = parseInt(bitRate, 10);\n    this.width = parseInt(width, 10);\n    this.height = parseInt(height, 10);\n    this.mediaConstraints = {\n        audio: true,\n        video: {\n            width: {ideal: this.width},\n            height: {ideal: this.height}\n        }\n    };\n    this.mimeTypes = [\n        'video/webm;codecs=vp9,opus',\n        'video/webm;codecs=h264,opus',\n        'video/webm;codecs=vp8,opus'\n    ];\n}\n\n/**\n * Represents one record audio or video question.\n *\n * @param {string} questionId id of the outer question div.\n * @param {Object} settings like audio bit rate.\n * @constructor\n */\nfunction RecordRtcQuestion(questionId, settings) {\n    const questionDiv = document.getElementById(questionId);\n\n    // Check if the RTC API can work here.\n    const result = checkCanWork();\n    if (result === 'nothttps') {\n        questionDiv.querySelector('.https-warning').classList.remove('hide');\n        return;\n    } else if (result === 'nowebrtc') {\n        questionDiv.querySelector('.no-webrtc-warning').classList.remove('hide');\n        return;\n    }\n\n    // Make the callback functions available.\n    this.showAlert = showAlert;\n    this.notifyRecordingComplete = notifyRecordingComplete;\n    this.notifyButtonStatesChanged = setSubmitButtonState;\n    const thisQuestion = this;\n\n    // We may have more than one widget in a question.\n    questionDiv.querySelectorAll('.qtype_recordrtc-audio-widget, .qtype_recordrtc-video-widget').forEach(function(widget) {\n        // Get the appropriate options.\n        let typeInfo;\n        if (widget.dataset.mediaType === 'audio') {\n            typeInfo = new AudioSettings(settings.audioBitRate);\n        } else {\n            typeInfo = new VideoSettings(settings.videoBitRate, settings.videoWidth, settings.videoHeight);\n        }\n\n        // Create the recorder.\n        new Recorder(widget, typeInfo, thisQuestion, settings);\n        return 'Not used';\n    });\n    setSubmitButtonState();\n\n    /**\n     * Set the state of the question's submit button.\n     *\n     * If any recorder does not yet have a recording, then disable the button.\n     * Otherwise, enable it.\n     */\n    function setSubmitButtonState() {\n        let anyRecorded = false;\n        questionDiv.querySelectorAll('.qtype_recordrtc-audio-widget, .qtype_recordrtc-video-widget').forEach(function(widget) {\n            if (widget.dataset.state === 'recorded') {\n                anyRecorded = true;\n            }\n        });\n        const submitButton = questionDiv.querySelector('input.submit[type=submit]');\n        if (submitButton) {\n            submitButton.disabled = !anyRecorded;\n        }\n    }\n\n    /**\n     * Show a modal alert.\n     *\n     * @param {string} subject Subject is the content of the alert (which error the alert is for).\n     * @return {Promise}\n     */\n    function showAlert(subject) {\n        return ModalFactory.create({\n            type: ModalFactory.types.ALERT,\n            title: M.util.get_string(subject + '_title', 'qtype_recordrtc'),\n            body: M.util.get_string(subject, 'qtype_recordrtc'),\n        }).then(function(modal) {\n            modal.show();\n            return modal;\n        });\n    }\n\n    /**\n     * Callback called when the recording is completed.\n     *\n     * @param {Recorder} recorder the recorder.\n     */\n    function notifyRecordingComplete(recorder) {\n        recorder.uploadMediaToServer();\n    }\n}\n\n/**\n * Initialise a record audio or video question.\n *\n * @param {string} questionId id of the outer question div.\n * @param {Object} settings like audio bit rate.\n */\nfunction init(questionId, settings) {\n    M.util.js_pending('init-' + questionId);\n    new RecordRtcQuestion(questionId, settings);\n    M.util.js_complete('init-' + questionId);\n}\n\nexport {\n    init\n};\n"],"names":["Recorder","widget","mediaSettings","owner","uploadInfo","recorder","this","mediaStream","mediaRecorder","chunks","bytesRecordedSoFar","timeRemaining","stopTime","countdownTicker","button","querySelector","pauseButton","controlRow","mediaElement","name","noMediaPlaceholder","timeDisplay","handleCaptureStarting","stream","srcObject","muted","startSaving","play","controls","dataset","state","setButtonLabel","disabled","focus","MediaRecorder","options","audioBitsPerSecond","bitRate","videoBitsPerSecond","videoWidth","width","videoHeight","height","i","mimeTypes","length","isTypeSupported","mimeType","getRecordingOptions","ondataavailable","handleDataAvailable","onpause","onstop","handleRecordingHasStopped","start","maxRecordingDuration","resumeCountdownTimer","updateTimerDisplay","parentElement","classList","add","remove","event","data","size","maxUploadSize","localStorage","getItem","removeItem","setItem","stopRecording","showAlert","push","M","core_formchangechecker","window","location","pathname","endsWith","set_form_changed","stopCountdownTimer","denyRerecord","setPauseButtonLabel","stop","tracks","getTracks","blob","Blob","type","src","URL","createObjectURL","notifyRecordingComplete","handleCaptureFailed","error","debug","setPlaceholderMessage","stringName","replace","toLowerCase","enableAllButtons","Date","now","clearInterval","setInterval","millisecondsRemaining","secondsRemaining","Math","round","secs","mins","innerText","util","get_string","pad","val","valString","handleRecordingFetched","e","fetchRequest","target","status","response","formData","FormData","append","recordingFilename","cfg","sesskey","uploadRepositoryId","draftItemId","contextId","uploadRequest","XMLHttpRequest","addEventListener","handleUploadReadyStateChanged","upload","handleUploadProgress","handleUploadError","handleUploadAbort","open","wwwroot","send","readyState","JSON","parse","responseText","errorcode","loaded","total","langString","a","widgetName","innerHTML","textContent","disableOrEnableButtons","notifyButtonStatesChanged","enabled","closest","querySelectorAll","forEach","clickedButton","preventDefault","navigator","mediaDevices","getUserMedia","mediaConstraints","then","catch","startRecording","pause","resume","uploadMediaToServer","responseType","AudioSettings","parseInt","audio","VideoSettings","video","ideal","RecordRtcQuestion","questionId","settings","questionDiv","document","getElementById","result","protocol","host","indexOf","subject","ModalFactory","create","types","ALERT","title","body","modal","show","setSubmitButtonState","thisQuestion","mediaType","audioBitRate","videoBitRate","anyRecorded","submitButton","js_pending","js_complete"],"mappings":";;;;;;;;;;;;;;;;;;cA2ESA,SAASC,OAAQC,cAAeC,MAAOC,gBAItCC,SAAWC,KAKbC,YAAc,KAKdC,cAAgB,KAKhBC,OAAS,GAMTC,mBAAqB,EAKrBC,cAAgB,EAMhBC,SAAW,EAKXC,gBAAkB,EAEhBC,OAASb,OAAOc,cAAc,sCAC9BC,YAAcf,OAAOc,cAAc,wCACnCE,WAAahB,OAAOc,cAAc,gCAClCG,aAAejB,OAAOc,cAAc,iCAAmCb,cAAciB,MACrFC,mBAAqBnB,OAAOc,cAAc,6CAC1CM,YAAcpB,OAAOc,cAAc,uCA6EhCO,sBAAsBC,QAC3BhB,YAAcgB,OAGdL,aAAaM,UAAYD,OACzBL,aAAaO,OAAQ,EACM,UAAvBvB,cAAciB,KACdO,eAEAR,aAAaS,OACbT,aAAaU,UAAW,EAExB3B,OAAO4B,QAAQC,MAAQ,WACvBC,eAAe,kBACf9B,OAAOc,cAAc,gCAAgCiB,UAAW,GAIhEhB,cACAA,YAAYgB,UAAW,GAE3BlB,OAAOkB,UAAW,EAClBlB,OAAOmB,iBAOFP,eAELlB,cAAgB,IAAI0B,cAAc3B,2BA2X5B4B,QAAU,MAGW,UAAvBjC,cAAciB,KACdgB,QAAQC,mBAAqBlC,cAAcmC,aACxC,GAA2B,UAAvBnC,cAAciB,KAAkB,CACvCgB,QAAQG,mBAAqBpC,cAAcmC,QAC3CF,QAAQI,WAAarC,cAAcsC,MACnCL,QAAQM,YAAcvC,cAAcwC,WAG/B,IAAIC,EAAI,EAAGA,EAAIzC,cAAc0C,UAAUC,OAAQF,OAC5CT,cAAcY,gBAAgB5C,cAAc0C,UAAUD,IAAK,CAC3DR,QAAQY,SAAW7C,cAAc0C,UAAUD,iBAMhDR,QA9YwCa,KAEjCC,gBAAkBC,oBAChC1C,cAAc2C,QAAUD,oBACxB1C,cAAc4C,OAASC,0BACvB7C,cAAc8C,MAAM,KAEpBrD,OAAO4B,QAAQC,MAAQ,YACvBC,eAAe,iBA+KfpB,cAAsD,IAAtCV,OAAO4B,QAAQ0B,qBAC/BC,uBACAC,qBA/K2B,UAAvBvD,cAAciB,OACdL,OAAO4C,cAAcC,UAAUC,IAAI,QACnC3C,WAAW0C,UAAUE,OAAO,QAC5B5C,WAAW0C,UAAUC,IAAI,oBASxBV,oBAAoBY,OACpBA,MAAMC,OAKXrD,oBAAsBoD,MAAMC,KAAKC,KAC7B5D,WAAW6D,eAAiB,GAAKvD,oBAAsBN,WAAW6D,gBAG7DC,aAAaC,QAAQ,WAMtBD,aAAaE,WAAW,YALxBF,aAAaG,QAAQ,UAAW,QAChCC,gBACAnE,MAAMoE,UAAU,oBAQxB9D,OAAO+D,KAAKV,MAAMC,WAIsB,IAA7BU,EAAEC,wBACRC,OAAOC,SAASC,SAASC,SAAS,0BACnCL,EAAEC,uBAAuBK,6BA6BxBT,gBAELxD,OAAOkB,UAAW,EAGlBgD,qBAGI/E,OAAO4B,QAAQoD,cACfnE,OAAO+C,SACH7C,aACAA,YAAY0C,cAAcG,WAG9B/C,OAAO6C,UAAUE,OAAO,cACxB/C,OAAO6C,UAAUC,IAAI,sBACjB5C,cACAkE,oBAAoB,SACpBlE,YAAY0C,cAAcC,UAAUC,IAAI,UAKhDpD,cAAc2E,eAGRC,OAAS7E,YAAY8E,YAClB1C,EAAI,EAAGA,EAAIyC,OAAOvC,OAAQF,IAC/ByC,OAAOzC,GAAGwC,gBAOT9B,+BACwB,QAAzBpD,OAAO4B,QAAQC,iCAMbwD,KAAO,IAAIC,KAAK9E,OAAQ,CAAC+E,KAAMhF,cAAcuC,cACnD7B,aAAaM,UAAY,KACzBN,aAAauE,IAAMC,IAAIC,gBAAgBL,MAGvCpE,aAAaO,OAAQ,EACrBP,aAAaU,UAAW,EACxBV,aAAawC,cAAcC,UAAUE,OAAO,QAC5CzC,mBAAmBuC,UAAUC,IAAI,QACjC1C,aAAae,QAEc,UAAvB/B,cAAciB,KACdE,YAAYsC,UAAUC,IAAI,2CAE1B9C,OAAO4C,sEAAeC,UAAUE,OAAO,QACvC5C,WAAW0C,UAAUC,IAAI,QACzB3C,WAAW0C,UAAUE,OAAO,UAI5B/C,OAAO4C,gBACP5C,OAAOkB,UAAW,EAClBlB,OAAO6C,UAAUE,OAAO,cACxB/C,OAAO6C,UAAUC,IAAI,uBAGzB3D,OAAO4B,QAAQC,MAAQ,WAEnBrB,OAAOoC,OAAS,GAChB1C,MAAMyF,wBAAwBvF,oBAS7BwF,oBAAoBC,oBACrBC,MAAM,qDACNA,MAAMD,OAEVE,sBAAsB,mBACtBjE,eAAe,gBACfjB,OAAO6C,UAAUE,OAAO,cACxB/C,OAAO6C,UAAUC,IAAI,sBACrB3D,OAAO4B,QAAQC,MAAQ,MAEnBtB,eACAA,cAAc2E,WAIZc,WAAa,MAAQH,MAAM3E,KAAK+E,QAAQ,QAAS,IAAIC,cAE3DhG,MAAMoE,UAAU0B,YAChBG,4BAeKpB,qBACLrE,cAAgBC,SAAWyF,KAAKC,MACR,IAApBzF,kBACA0F,cAAc1F,iBACdA,gBAAkB,YAOjB2C,uBACL5C,SAAWyF,KAAKC,MAAQ3F,cACA,IAApBE,kBACAA,gBAAkB2F,YAAY/C,mBAAoB,eAOjDA,yBACCgD,sBAAwB7F,SAAWyF,KAAKC,MACxCI,iBAAmBC,KAAKC,MAAMH,sBAAwB,KACtDI,KAAOH,iBAAmB,GAC1BI,KAAOH,KAAKC,OAAOF,iBAAmBG,MAAQ,IAEpDxF,YAAY0F,UAAYtC,EAAEuC,KAAKC,WAAW,cAAe,kBACjD,CAACH,KAAMI,IAAIJ,MAAOD,KAAMK,IAAIL,QAEhCJ,uBAAyB,GACzBnC,yBAUC4C,IAAIC,SACHC,UAAYD,IAAM,UAEpBC,UAAUvE,OAAS,EACZ,IAAMuE,UAEN,GAAKA,mBAuBXC,uBAAuBC,OACtBC,aAAeD,EAAEE,UACK,MAAxBD,aAAaE,YAMXnC,KAAOiC,aAAaG,SAGpBC,SAAW,IAAIC,SACrBD,SAASE,OAAO,mBAAoBvC,KAAMrF,OAAO4B,QAAQiG,mBACzDH,SAASE,OAAO,UAAWpD,EAAEsD,IAAIC,SACjCL,SAASE,OAAO,UAAWzH,WAAW6H,oBACtCN,SAASE,OAAO,SAAUzH,WAAW8H,aACrCP,SAASE,OAAO,WAAY,KAC5BF,SAASE,OAAO,SAAUzH,WAAW+H,WACrCR,SAASE,OAAO,YAAa,SAEvBO,cAAgB,IAAIC,eAC1BD,cAAcE,iBAAiB,mBAAoBC,+BACnDH,cAAcI,OAAOF,iBAAiB,WAAYG,sBAClDL,cAAcE,iBAAiB,QAASI,mBACxCN,cAAcE,iBAAiB,QAASK,mBACxCP,cAAcQ,KAAK,OAAQnE,EAAEsD,IAAIc,QAAU,iDAC3CT,cAAcU,KAAKnB,oBAOdY,8BAA8BjB,OAC7Bc,cAAgBd,EAAEE,OACS,IAA7BY,cAAcW,aAIDC,KAAKC,MAAMb,cAAcc,cAC7BC,WACTT,oBAGyB,MAAzBN,cAAcX,QAEd1F,eAAe,gBACfqE,oBACgC,MAAzBgC,cAAcX,SACrBzB,sBAAsB,mBACtBI,8BAQCqC,qBAAqBnB,GAC1BvF,eAAe,iBAAkB4E,KAAKC,MAAMU,EAAE8B,OAAS9B,EAAE+B,MAAQ,KAAO,cAMnEX,oBACL1C,sBAAsB,gBACtBI,4BAMKuC,oBACL3C,sBAAsB,iBACtBI,4BASKrE,eAAeuH,WAAYC,GAC3BA,IAEDA,EAAI,+BAAiCtJ,OAAO4B,QAAQ2H,WAAa,WAErE1I,OAAO2I,UAAYhF,EAAEuC,KAAKC,WAAWqC,WAAY,kBAAmBC,YAQ/DrE,oBAAoBoE,YACzBtI,YAAY+F,UAAYtC,EAAEuC,KAAKC,WAAWqC,WAAY,4BAQjDtD,sBAAsBsD,YAC3BlI,mBAAmBsI,YAAcjF,EAAEuC,KAAKC,WAAWqC,WAAY,mBAC/DpI,aAAawC,cAAcC,UAAUC,IAAI,QACzCxC,mBAAmBuC,UAAUE,OAAO,iBAkC/BuC,mBACLuD,wBAAuB,GACvBxJ,MAAMyJ,qCAeDD,6BAAuBE,gEAC5B5J,OAAO6J,QAAQ,QAAQC,iBAAiB,kDAAkDC,SACtF,SAASlJ,QACLA,OAAOkB,UAAY6H,WAlhB/B5J,OAAOqI,iBAAiB,kBAQGhB,OACjB2C,cAAgB3C,EAAEE,OAAOsC,QAAQ,cAClCG,4BAGL3C,EAAE4C,iBACMjK,OAAO4B,QAAQC,WACd,UACA,uBA4BkB,UAAvB5B,cAAciB,MACdD,aAAawC,cAAcC,UAAUC,IAAI,QACzCxC,mBAAmBuC,UAAUC,IAAI,QACjCvC,YAAYsC,UAAUE,OAAO,UAG7B3C,aAAawC,cAAcC,UAAUE,OAAO,QAC5CzC,mBAAmBuC,UAAUC,IAAI,SAErC5C,MAAAA,aAAAA,YAAa0C,cAAcC,UAAUE,OAAO,QAG5C/C,OAAO6C,UAAUE,OAAO,sBACxB/C,OAAO6C,UAAUC,IAAI,cA8crB+F,wBAAuB,GAxcvBlJ,OAAS,GACTC,mBAAqB,EACrByJ,UAAUC,aAAaC,aAAanK,cAAcoK,kBAC7CC,KAAKjJ,uBACLkJ,MAAM3E,qBAlDH4E,aAEC,WACD/I,wBAEC,YACGuI,gBAAkBjJ,aA6I9BgE,qBACAE,oBAAoB,UACpB1E,cAAckK,QACdzK,OAAO4B,QAAQC,MAAQ,UA7IXwC,0BAGH,SACG2F,gBAAkBjJ,aAiJ9BwC,uBACAvD,OAAO4B,QAAQC,MAAQ,YACvBoD,oBAAoB,SACpB1E,cAAcmK,UAjJFrG,yBAhCXsG,+BA+VD7I,eAAe,uBAGTwF,aAAe,IAAIc,eACzBd,aAAaqB,KAAK,MAAO1H,aAAauE,KACtC8B,aAAasD,aAAe,OAC5BtD,aAAae,iBAAiB,OAAQjB,wBACtCE,aAAauB,iBAuLZgC,cAAczI,cACdlB,KAAO,aACPkB,QAAU0I,SAAS1I,QAAS,SAC5BiI,iBAAmB,CACpBU,OAAO,QAENpI,UAAY,CACb,yBACA,kCAYCqI,cAAc5I,QAASG,MAAOE,aAC9BvB,KAAO,aACPkB,QAAU0I,SAAS1I,QAAS,SAC5BG,MAAQuI,SAASvI,MAAO,SACxBE,OAASqI,SAASrI,OAAQ,SAC1B4H,iBAAmB,CACpBU,OAAO,EACPE,MAAO,CACH1I,MAAO,CAAC2I,MAAO7K,KAAKkC,OACpBE,OAAQ,CAACyI,MAAO7K,KAAKoC,eAGxBE,UAAY,CACb,6BACA,8BACA,uCAWCwI,kBAAkBC,WAAYC,cAC7BC,YAAcC,SAASC,eAAeJ,YAGtCK,OAjqBAvB,UAAUC,cAAgBzF,OAAOzC,cAIX,WAAtB0C,SAAS+G,WAAiE,IAAxC/G,SAASgH,KAAKC,QAAQ,aACnD,WAGJ,KAPI,cAiqBI,aAAXH,OAGG,GAAe,aAAXA,OAAJ,MAMFnH,mBA8CcuH,gBACRC,uBAAaC,OAAO,CACvBxG,KAAMuG,uBAAaE,MAAMC,MACzBC,MAAO1H,EAAEuC,KAAKC,WAAW6E,QAAU,SAAU,mBAC7CM,KAAM3H,EAAEuC,KAAKC,WAAW6E,QAAS,qBAClCvB,MAAK,SAAS8B,cACbA,MAAMC,OACCD,eApDVzG,iCA6D4BvF,UAC7BA,SAASuK,4BA7DRhB,0BAA4B2C,yBAC3BC,aAAelM,KAGrBiL,YAAYxB,iBAAiB,gEAAgEC,SAAQ,SAAS/J,mBAUtGD,SAASC,OAPoB,UAA7BA,OAAO4B,QAAQ4K,UACJ,IAAI3B,cAAcQ,SAASoB,cAE3B,IAAIzB,cAAcK,SAASqB,aAAcrB,SAAS/I,WAAY+I,SAAS7I,aAIvD+J,aAAclB,UACtC,cAEXiB,4BAxBIhB,YAAYxK,cAAc,sBAAsB4C,UAAUE,OAAO,aAHjE0H,YAAYxK,cAAc,kBAAkB4C,UAAUE,OAAO,iBAmCxD0I,2BACDK,aAAc,EAClBrB,YAAYxB,iBAAiB,gEAAgEC,SAAQ,SAAS/J,QAC7E,aAAzBA,OAAO4B,QAAQC,QACf8K,aAAc,UAGhBC,aAAetB,YAAYxK,cAAc,6BAC3C8L,eACAA,aAAa7K,UAAY4K,6FAqCvBvB,WAAYC,UACtB7G,EAAEuC,KAAK8F,WAAW,QAAUzB,gBACxBD,kBAAkBC,WAAYC,UAClC7G,EAAEuC,KAAK+F,YAAY,QAAU1B"}